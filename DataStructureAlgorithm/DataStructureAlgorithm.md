# Algorithm

정리될 내용들은 아래와 같습니다.

- 개념 / 용어 정의, 사용 이유
- 구현 방법, 부분 로직별 설명
- Interview Question, Answer

#### 알고리즘

- 아랍의 수학자, 알콰리즈미 이름에서 유래
- 문제 이해 후 문제 해결을 위한 단계를 세우고 이를 적용해 문제를 해결하는 과정
  - 컴퓨터에게 명령하기 위해서는 일의 순서를 세분화해서 명령을 내려야 함
- 절차
- 문제나 과제를 해결하기 위한 처리 절차를 하나하나 구체적인 순서에 따라 표현한 아이디어나 생각

#### 알고리즘의 조건

- 입력
- 출력
- 명확성
- 유한성(종결성): 명령어 수행 후 유한 시간 내에 종료
- 효율성: 모든 과정은 명백하게 실행 가능 / 검증 가능한 것이어야 함

#### 알고리즘의 4단계 설명

- 문제 정의: 해결하고자 하는 바를 input / output 으로 나눠서 정의
- 알고리즘 설명: 해결하기 위해 할 일들을 단계적으로 정의
- 정확성 증명: 알고리즘이 맞는지 수학적으로 증명
- 성능 분석: 시간, 공간 복잡도

#### 프로그램 / 프로그래밍 개념

- 프로그램: 알고리즘을 프로그래밍 언어로 기술한 것
- 프로그래밍: 프로그램을 작성하는 작업
- 프로그래밍 언어: 컴퓨터에 지시하기 위한 인공 언어
- 프로그램 작성 흐름
  - 기획 => 설계 => 프로그래밍(코딩) => 테스트 / 디버깅 => 문서 작성

#### 알고리즘 분석 방법

- 시간 복잡도 (Time Complexity) - 속도
- 공간 복잡도 (Space Complexity) - 메모리 사용량
- 참고.
  - 일반적으로 복잡도를 이야기할 때 이는 시간 복잡도를 의미
  - 알고리즘은 시간을 더 중요시

#### 알고리즘 문제 해결 전략 설명

- 반복
- 재귀반복
- 완전 탐색
- 역추적
- 발견법
- 분할 정복

#### 알고리즘 종류

- 정렬: 선택 / 삽입 / 병합 / 퀵
- 탐색: 순차 탐색
- 그래프
  - 그래프 탐색: 깊이 우선 탐색 / 너비 우선 탐색
  - 경로 탐색

#### 알고리즘의 세가지 기본형 (기본 구조) 설명

- 순차 구조
- 선택 구조
- 반복 구조

#### 빅오 표기법 설명 (Big-O notation)

- 알고리즘 최악의 실행 시간 표기, 최소한 보장되는 성능 표기, 가장 일반적으로 사용
  - 그 외 표기법: 빅 오메가 (최상의 실행 시간), 빅 세타 (평균 실행 시간)
- 상수항 / 계수 무시
- 최고차항만 표시
- 종류
  - 실행 속도 O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) <-- 가장 느림

#### 정렬 알고리즘에서 Stable, Unstable에 대한 설명

- 순서 : 같은 값의 정렬 후 위치
- 각각에 해당하는 알고리즘에 대해 설명
  - Stable: 삽입, 합병
  - Unstable: 선택, 힙, 퀵
- 구체적인 구현 내용
  - 합병: 분할
  - 퀵: 피벗
- 시간 복잡도
  - 합병: nlogn
  - 퀵: nlogn ~ n^2 (최악의 경우)
- 각각의 장단점 / 언제 사용하면 좋은지?
  - 시간 복잡도, In-place, Stable

#### 동적 프로그래밍(DP, Dynamic Programming) 설명

- 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식
- 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상 시킬 수 있음
- 2가지 조건
  - 중복되는 부분(작은) 문제
  - 최적 부분 구조

#### 메모이제이션 (Memoization) 기법 설명

- 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 재사용함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

#### 동적 프로그래밍(Dynamic Programming)의 두 가지 조건 설명

- 다음의 조건을 만족해야 함
  - Overlapping Subproblem(중복되는 부분문제): 주어진 문제는 같은 부분 문제가 여러번 재사용됨
  - Optimal Substructure(최적 부분구조): 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있음

#### 재귀 알고리즘과 재귀의 시간 복잡도 설명

- 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘
- 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요
- 팩토리얼을 계산하는 재귀 함수에서는 T(n) = T(n-1) + c (C는 n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 O(n)이 됨

#### 정렬 알고리즘 설명

- **버블정렬** (Bubble Sort)
  - 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘
  - 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬
  - 시간복잡도 O(n^2)
- **선택정렬** (Selection Sort)
  - 첫 번째 값을 두번째부터 마지막 값까지 차례대로 비교하여 최소값을 첫 번째에 놓음
  - 두 번째 값을 세번째부터 마지막 값까지 비교하여 최소값을 찾아 두 번째 위치에 놓음
  - 위 과정을 반복하며 정렬하는 알고리즘
  - 시간복잡도 O(n^2)
- **힙 정렬** (Heap Sort)
  - 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘
  - 힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우에 적합
  - 시간복잡도는 O(nlog2n)
- **병합정렬** (Merge Sort)
  - 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘
  - 시간복잡도는 O(nlog2n)
- **퀵 정렬** (Quick Sort)
  - 매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할
  - 피벗을 설정하고 피벗보다 큰값과 작은값으로 분할하여 정렬
  - 시간복잡도
    - 최선 / 평균의 경우: O(nlog2n)
    - 리스트가 계속해서 불균등하게 나눠지는 경우는 O(n^2)
- **삽입정렬** (Injection Sort)
  - 두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
  - 두 번째 값과 첫번째 값 비교 후 서로 위치 변경
  - 세 번째 값과 두번째 (필요시 첫번째) 값들 비교 후 위치 변경
  - 이 과정을 반복
  - 시간 복잡도
    - 평균: O(n^2)
    - 가장 빠른 경우는 O(n)
    - 최악의 경우: O(n^2)

#### n개의 배열에서 k(k<=n) 번째로 큰수를 찾는 알고리즘 설명

- 일반적으로 퀵정렬을 사용
- 퀵정렬을 사용하면 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 되는 문제 발생
- 퀵선택 알고리즘은 퀵정렬을 한 후에 피봇과 K를 비교하여 아래와 같이 수행
  - pivot의 인덱스가 k와 같은 경우 : 그대로 그 인덱스의 값을 리턴
  - pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스+1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다
  - pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스-1까지 다시 Partition함수에 넘겨준다
- 퀵정렬과 퀵선택 알고리즘 차이점
  - Pivot의 인덱스가 7이고 K가 5인 경우에, 피봇의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행
  - 퀵선택 알고리즘의 시간복잡도: n+n/2+4/n+....1=O(n)

#### 빅오(Big-O) 표기법의 시간 복잡도 크기 순서

- O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)

#### 허프만 코딩 설명

- 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여
- 접두부 코드와 최적 코드를 사용
  - 접두부 코드: 문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드
  - 최적코드: 인코딩된 메세지의 길이가 가장 짧은 코드

#### 알고리즘 테스트의 목적

- 문제 해결력
- 예외 상황과 경계값 처리
- 코드 가독성과 중복 제거 등 관련한 코드의 품질
- 언어 자체에 대한 이해도
- 효율적인 로직
- => 문제를 어떻게 창의적으로 해결을 할 것인가를 측정하기 위한 목적

#### 알고리즘 문제 해결을 위한 접근법 및 생각법 정리

- 접근법
  - 문제에 대한 능동적, 공격적 받아들임
  - 필요한 정보를 추가적으로 요구
  - 문제 자체에 대한 완벽한 이해 필요
  - 문제를 익숙한 용어로 재정의 / 해결하기 위한 정보를 추출 <== 추상화 과정
  - 추상화된 데이터를 바탕으로 문제 해결 계획 수립 (사용할 알고리즘과 자료구조 선택)
  - 수립한 계획에 대해 검증 시도
    - Pseudo 코드 작성 또는 의견 수집
  - 계획 실행
- 생각법
  - 비슷한 문제를 항상 생각하려고 시도
  - 단순한 방법에서 시작해서 점진적 개선 시도
  - 작은 값을 생각 시도
  - 그림으로 그리기 시도
  - 수식으로 표현 시도
  - 풀이 순서를 강제
  - 뒤에서부터 생각

#### DFS, BFS에 대한 설명 (그래프 탐색 알고리즘)

- [DFS]: **깊이** 우선 탐색 (Depth First Search)
  - "더 나아갈 길이 보이지 않을 때까지 깊이 들어간다"를 원칙으로 그래프 내의 정점을 방문하는 알고리즘
  - 끝까지 깊이 들어갔다가 방문해왔던 정점 말고는 다른 이웃을 갖고 있지 않은 정점을 만나게 되면 다시 뒤로 돌아와 다른 경로로 뻗어 있는 정점을 타고 방문을 재개하는 방식으로 동작
  - 루트 노드 (또는 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
  - 모든 노드를 방문하고자 하는 경우에 선택 (완전 탐색 알고리즘에 자주 이용)
  - 자기 자신을 호출하는 순환 알고리즘
  - 트리 순회 (전위, 중위, 후위 순회)는 모두 DFS의 한 종류
  - 그래프 탐색의 경우 어떤 노드를 방문했었는지의 여부를 반드시 검사 필요 (무한 루프 방지의 목적)
- [BFS]: **너비** 우선 탐색 (Breadth First Search)
  - "꼼꼼하게 좌우를 살피며 다니자"
  - 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 알고리즘
  - 깊이 1인 모든 정점 방문 후 그 다음 깊이 정점들 방문
  - 더 이상 방문할 정점이 없는 경우에 탐색을 종료
  - 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법
  - 두 노드 사이의 최단 경로 또는 임의의 경로를 찾고 싶을 때 이 방법 선택
  - 시작 정점으로부터 거리가 가까운 정점의 순서로 탐색
  - 어떤 노드를 방문했었는지 여부를 반드시 검사
  - 재귀적으로 동작하지 않음
  - 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 큐를 사용 (FIFO)
  - 일반적으로 큐를 이용해서 반복적 형태로 구현

#### 최소 비용 신장 트리(MST, Minimum Spanning Tree) 알고리즘 설명

- 신장 트리(Spanning Tree)
- 크루스칼 (Kruskal) 알고리즘
- 프림 (Prim) 알고리즘

#### 최단 경로(Shortest Path) 알고리즘 설명

- 다익스트라 (Dijkstra) 알고리즘
- 플로이드 (Floyd) 알고리즘

#### Union-Find 알고리즘 설명

- Union-Find

#### 백트래킹 (Back Tracking)

- 모든 경우의 수를 전부 고려하는 알고리즘
- 답을 찾는 도중 답이 아니어서 막히면, 되돌아가서 다시 답을 찾아가는 기법
- 퇴각검색
- 현재 상태에서 가능한 모든 경로를 따라 들어가 탐색하다, 원하는 값과 불일치하는 부분이 발생하면 더 이상 탐색을 진행하지 않고 전 단계로 돌아가는, 즉 이름 그대로 방금 왔던 길을 되돌아가는 알고리즘

#### 자료구조 (Data Structure) 개념

- 데이터 값의 모임
- 자료의 집합
- 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
- 메모리 공간을 효율적으로 사용해야 하는데에 필요한 것
- 자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
  - 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임

#### 자료구조의 종류

- 단순 구조
  - 정수, 실수, 문자, 문자열
- 선형 구조
  - 배열, 연결리스트, 스택, 큐
- 비선형 구조
  - 트리, 그래프

#### 자료구조에서 암호화하는 방법 설명

- 해싱 (허프만 코드)
- 실제 활용 예시
  - 대칭키
  - 공개키
  - 비밀번호
  - HTTPS
- 대칭키와 공개키에 대한 설명
  - 암호화 키, 복호화 키
- 해싱에서 효율적으로 암호화하는 방식
  - 해시함수 (해시 충돌) SHA-256
- HTTPS의 암호화는 진행 방식
  - 세션키, 인증서

#### 해시 (Hash) 설명

- 해시함수를 통해 임의의 난수를 만드는 것
- A라는 문자열을 해시함수를 통해 B라고 만들었을 때 이 B를 가지고 A를 유추할 수 없게 하는 것
  - B를 데이터베이스에 저장
  - A라는 같은 값을 입력했을 때 해시함수를 돌리면 B가 출력
  - 이 값을 데이터베이스에 있는 값과 비교
- 단방향 암호화
- 암호화는 A -> B -> A (복호화를 통해 다시 A를 알아낼 수 있음)
- 예시
  - 해시: SHA256
  - 암호화: RSA

#### 백만명/천만명 이상의 특정 정보 노티피케이션과 저장 방법 설명

- 메세지큐에 담아 각각의 여러 서버에서 병렬 처리
- 그냥 데이터를 저장하게 되면 모든 테이블을 살펴야 하는 문제점 발생
  - 비효율, 저장용량 증가
- Key: Value list 형식으로 저장
  - 이미 있는 데이터를 다시 Write 해야 되는 단점

#### 2개의 큐로 스택 구현 과정

- 메인 / 서브 큐로 구성
- 원래 서브 큐안에 1이라는 데이터가 있었다고 가정
- 메인 큐에 데이터 입력되는 시점에 원래 메인 큐에 있던 데이터들을 서브 큐로 이동
  - 메인: 0, 서브: 1
- 메인 큐에 데이터 입력 완료
  - 메인: 2, 서브: 1
- 서브 큐안의 데이터들을 메인 큐로 이동
  - 메인 1, 2, 서브: 0

#### 2개의 스택으로 큐 구현 과정

- Stack1은 data를 넣는 용도로만 쓰고, Stack2는 data를 빼는 용도로만 사용
- Stack1로는 data를 입력 받음
  - 1, 2, 3 데이터 입력, 아래부터 1 => 2 => 3 순으로 적재
- Stack2에서는 data를 pop
  - 이전에 존재하였던 데이터를 pop
- Stack2가 비어 있다면 Stack1에서 Stack2로 data를 이동
  - 스택 1에서 하나씩 이동, 아래부터 3 => 2 => 1 순으로 적재

#### 해시맵 (HashMap)과 트리맵 (TreeMap)의 차이점

- 해시맵
  - 해시 이용한 저장을 하므로 순서 보장이 안됨
  - 해시 이용하여 배열에 접근 가능 O(1)
- 트리맵
  - Entry를 트리 형태로 저장하여 저장할 때 키 값을 기준으로 자동으로 정렬되어 저장
  - 트리 구조의 특성상 특정 Entry에 접근하기 위해서는 O(logn)

#### Array와 ArrayList 차이

- Array
  - 초기화 시 배열 사이즈 고정
  - 초기화 시 메모리에 할당되어 ArrayList보다 속도 빠름
  - 사이즈 변경 불가
  - 다차원 배열 가능
- ArrayList
  - 가변적인 크기
  - 데이터 추가 / 삭제 시 메모리를 재할당하므로 속도가 Array 보다 느림
  - 추가 / 삭제 가능
  - 다차원 배열 사용 불가능

#### LinkedList와 ArrayList 차이

- ArrayList
  - ArrayList는 데이터들이 순서대로 늘어선 배열의 형식
  - 원하는 데이터에 무작위로 접근 가능
  - 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요
  - 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸림
- LinkedList
  - LinkedList는 자료의 주소값으로 서로 연결된 형식
  - 리스트의 크기에 영향 없이 데이터를 추가 가능
  - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠름
  - 무작위 접근이 불가능하며, 순차 접근만 가능

#### Array와 LinkedList 장/단점

- Array
  - 데이터에 접근하기 위한 인덱스가 존재
  - 인덱스로 원소에 접근 가능해서 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)의 성능으로 접근 가능
  - Random Access 가능하여 속도 빠름
  - 추후 데이터가 삭제되는 경우 배열의 빈 부분의 메모리가 낭비
  - 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없는 정적 자료형
  - 삽입 / 삭제 과정에서 각 원소들에 대한 shift 처리 비용 발생하므로 이런 경우에는 O(n)의 시간 복잡도 형성
  - 정리: 검색 빠르나 삽입/삭제 느림
- LinkedList
  - 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 변경해주면 삽입과 삭제를 O(1)로 해결 가능
  - 원하는 위치에 한번에 접근 불가능, 원하는 원치를 검색하는 과정에 있어서 1번째 원소부터 다 확인해야 하는 문제 발생
  - 삽입/삭제 빠르나 검색 느림
  - 빈틈없이 데이터를 적재하는 장점을 취한 자료형
  - 순서가 있으며 중복이 허용
  - 자동으로 엘리먼트를 수용할 수 있는 크기가 조정되고, 리스트 내의 엘리먼트의 실제 개수를 얄려줌
  - List 대표적인 기능
    - 처음, 끝, 중간에 엘리먼트를 추가/삭제 하는 기능
    - 리스트에 데이터가 있는지를 체크하는 기능
    - 리스트의 모든 데이터에 접근할 수 있는 기능

#### BST(이진 탐색 트리, Binary Search Tree)와 이진 트리 (Binary Tree) 에 대한 설명

- 이진 트리
  - 자식 노드가 최대 2개인 노드들로 구성된 트리
- 이진 탐색 트리
  - 이진 탐색 + 연결 리스트 결합한 자료구조
  - 이진 탐색의 효율적인 탐색 능력 유지, 빈번한 입력 / 삭제 가능
  - 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징
  - 트리 높이에 영향
  - 높이가 h일 때 O(h)의 시간 복잡도 형성
  - 트리의 균형이 한쪽으로 치우친 경우 최악의 경우가 되고 O(n)의 시간 복잡도 형성
    - 이를 극복하기 위해 나온 기법 => RBT(Red-Black Tree)

#### AVL 트리 설명

- 한 쪽으로 값이 치우치는 이진 탐색 트리(Binary Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리
- 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행

#### 레드블랙 (RBT, Red-Black Tree) 트리 설명

- BST 이진 탐색 트리를 기반으로 하는 트리 형식 자료 구조
- 노드의 child가 없는 경우 child를 가리키는 포인터는 NIL 값을 저장하고 이러한 NIL들을 leaf node로 간주
- 레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠
- 연결된 노드들은 색이 중복되지 않도록 관리됨

#### 스택, 큐, 트리, 힙 구조 설명

- 스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조
- 큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조
- 트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태
  - 계층이 있는 데이터를 표현하기에 적합
- 힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조
  - 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리

#### 우선순위 큐와 내부 구조 및 시간복잡도 설명

- 들어간 순서에 상관없이 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
- 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용
  - 구현 방식에는 힙 외에도 배열, 연결 리스트로 구현 가능
  - 힙 방식이 최악의 경우라도 시간 복잡도 O(logN)을 보장하므로 일반적으로 완전 이진트리 형태의 힙을 이용해 구현

#### 해시 테이블 (HashTable) / 시간 복잡도 설명

- (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용
  - 내부적으로 배열(버킷)을 사용하여 데이터 저장하므로 속도 빠름
- Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
- 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도 유지
- 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가 가능성 존재

#### HashMap과 HashTable 차이점

- 정리: 동기화 지원 여부와 Null 값 허용 여부에 차이
- HashTable
  - 동기화 고려 필요한 상황 하 병렬 처리를 할 때 Thread-Safe
  - Null 값 허용하지 않음
- HashMap
  - 병렬 처리를 하지 않을 때 Thread-Safe 하지 않음
  - Null 값 허용

#### Array의 특징, 장점 및 단점에 대한 설명

- 데이터를 순차적으로 저장
- 데이터에 순서 존재, 0부터 시작하는 인덱스 존재
- 인덱스를 통해 특정 요소를 찾고 조작 가능
- 데이터 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점 존재
- 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 부적절
- 적용의 좋은 예
  - 주식 차트
  - 날짜 별로 주식 가격이 차례대로 저장되어야 하는 데이터
  - 순서가 없는 자료구조 사용 시 날짜별 주식 가격 확인이 어렵고 매번 전체 자료를 읽어 들이고 비교해야 하는 문제 발생

#### Stack과 Queue의 실사용 예

- 자바의 스택 메모리 영역
  - 지역 / 매개 변수의 데이터 값이 저장되는 공간
  - 메소드 호출 시 메모리에 할당되고 종료되면 메모리가 해제되는 LIFO 구조
- OS의 스케쥴러

#### Data structure 키워드 정리

- Direct Address Table
- Stack
- Queue
- LinkedList
- Two Pointer
- Dynamic Array
- Array
- List
- Hash Table
- Hash Function
- Dictionary
- Collision
  - open addressing
  - separate chaining
- Random Access
- Time Complexity
- Space Complexity
- Memory
- Recursion (factorial, fibonacci)
  - recurrence relation
  - base case (핵심)
- Tree
  - Node
  - Edge
  - Root
  - Leaf
  - Child / Parent / Sibling
  - degree
    - 모든 노드의 차수가 n개 이하인 트리를 n진 트리
  - ancestor
  - descendant
  - height
  - level
  - Subtree
- Binary Tree (2진 트리)
- Complete Binary Tree (완전 이진 트리)
  - 왼쪽부터 오른쪽 순서로 채워나감
- 트리 순회 Traversal = 트리 탐색 (트리의 각 노드를 방문, 한번씩 방문해야 하므로 완전 탐색)
  - 너비 우선 탐색 BFS
    - Lv0 --> LvX
    - Queue, deque
    - Queue 상태만 봐도 다음에 어디 방문할지 예상가능
    - 접근과 방문 차이
  - 깊이 우선 탐색 DFS
    - Stack
    - Recursion*
      - 약간 서브트리에 위임한다는 느낌
    - 전위순회 (preorder)
      - 자식노드들한테 가기전에 먼저 방문
    - 중위순회 (inorder)
      - 좌측 노드한테 먼저가서 방문하고 그다음 자기 자신 방문 후 반대편 노드 방문
    - 후위순회 (postorder)
      - 자식 노드부터 다 방문 후에 자기 자신 방문