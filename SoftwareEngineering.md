# Software Engineering

정리될 내용들은 아래와 같습니다.

- 개념 / 용어 정의, 사용 이유
- Interview Question, Answer

#### 소프트웨어 공학 개념

- 소프트웨어와 관련된 원리, 지식, 도구등을 활용하여 새로운 제품, 도구등을 만드는 것
- 소프트웨어의 개발, 운용, 유지보수 등의 생명 주기 전반을 체계적으로 서술적이며 정량적으로 다루는 학문
- 시스템 개발 초기 단계부터 시스템이 사용된 후 유지보수되기까지의 소프트웨어 개발과 관련된 모든 측면

#### 소프트웨어 공학 개발 과정

- 계획, 요구사항 분석, 설계, 구현, 시험 / 유지 보수 과정
- 소프트웨어는 여러 구성요소가 하드웨어 / 다른 기타 요소들과 결합하여 유기적으로 상호작용하는 시스템
- 시스템 개발 시 우선 순위
  - 프로젝트 계획, 고객과 개발회사 계약

#### 소프트웨어 공학 필요한 이유

- 비용의 문제 (돈, 시간, 노력 등) 해결 / 감소 목적
- 시스템 복잡도 향상

#### 일반적인 소프트웨어 종류

- [Generic] Products
  - 소프트웨어가 어떤 것을 해야할 지 개발자가 결정해서 개발하는 소프트웨어
  - 유지보수도 개발자에 의해 진행
  - 특정 사용자가 사용하는 것을 목표로 하는 것이 아닌 대중들이 사용하길 원하는 소프트웨어
- [Customized] Products
  - 특정 고객의 요구사항에 맞춰 개발되는 소프트웨어
  - 유지보수 또한 고객의 요구사항에 맞춰 진행
  - 추후 업데이트 / 발생되는 변경사항들도 고객의 요구사항에 맞춰 진행
  - 개발 진행 전 고객과 충분한 커뮤니케이션 필요

#### 응용 프로그램 종류

- Batch Processing System: 대용량 데이터를 처리하는 프로그램
- Entertainment System: 유져가 즐길 수 있는 프로그램 (게임 등)
- System for Modeling and Simulation: 시뮬레이션이나 모델링을 위한 시스템
- Data Collection System: 다른 시스템에서 전달 받은 데이터들을 수집하는 시스템
- System of System: 다양한 시스템끼리 구성되어 상호작용

#### 좋은 소프트웨어가 가져야 할 특성

- 유지가능성 (Maintainability)
- 신뢰성과 보안 (Reliability and Security)
- 효율성 (Efficiency)
- 접근가능성 (Acceptability)

#### TDD (Test Driven Development) 설명

- 테스트 주도 개발
- 작은 단위의 테스트 케이스를 활용
- 테스트 케이스 작성 후 이를 통과하는 코드를 작성하는 방식으로 진행
- 짧은 개발 주기를 반복하는 개발 방식
  - 애자일 개발 방법론 중 eXtream Programming(XP)의 Test-First와 동일 맥락
- 일반적인 개발 과정
  - 설계 => 코드 작성 => 테스트 => 반복
  - 완벽한 설계 어려움
  - 요구사항 변경 가능성
- TDD 개발 과정
  - 설계 => 테스트 코드 작성 => 실제 코드 개발 => 리팩토링 => 반복
    - 실패하는 테스트 코드 작성
    - 테스트 통과 위한 실제 코드 작성
    - 코드 중복 제거 / 일반화 등의 리팩토링 수행
  - 코드의 모듈화 / 높은 재사용성 기대
  - 단위 테스트 기반하여 종속성 / 의존성이 낮은 모듈화 기대
  - 점진적 개선 효과
  - 생산성 저하 (개발 속도 저하)

#### 단위 테스트 (Unit Test) 설명

- 하나의 단위 클래스에 대한 기능 테스트 의미

#### 애자일 (Agile) 설명

- 소프트웨어 개발 방법론
- 일정한 주기를 가지고 반복적으로 프로토 타입을 만드는 개발 방법론
  - 필요한 요구 사항을 주기적으로 받아 수정 / 확장
- 개발 요구 사항은 계속 변경될 수 있으므로 이 문제 극복을 위해 애자일 방법론이 탄생
- 애자일 과정
  - 필요 기능 명시
  - 팀원과 스프린트 계획
    - 참고. 스프린트: 소규모 기능에 대해 계획, 개발, 테스트 과정을 포함하는 주기 의미
    - 회의에서 백 로그 + 스프린트 목표 논의
  - 스크럼 진행: 날마다 한 일 / 직면 문제 사항 공유
  - 스프린트 완료 후 회의 / 회고 진행
  - Jira 프로그램 활용한 스프린트 구체화

#### 페어 프로그래밍 (Pair Programming)

- 애자일 개발 방법론 중의 하나
- 하나의 개발 가능한 PC 에서 두 명의 개발자가 함께 작업하는 것
- 네비게이터(navigator)가 전략을 제시하고 드라이버(driver)가 실제 코드를 작성하며, 이 열할을 각자 번갈아가며 수행 (짝 프로그래밍이)
- 장점
  - 서로가 몰랐던 부분들을 상호보완 가능
  - 페어 프로그래밍을 진행하면 서로가 다른 분야의 기술을 알고 있을때 혹은 새로운 멤버가 들어올때, 팀의 개발환경이나 해당 기술에 대해서 공유 가능
  - 문서 전달 등의 방식보다 빠르게 지식 공유 가능
  - 업무 집중도 상승
  - 페어로 함께 개발을 하면 실시간 코드 리뷰와 함께 올바르게 설계를 하고 개발의 목적에 맞는 방향으로 가고 있는지에 대해서 팀원간의 지속적인 대화와 확인이 가능
  - 업무에 대한 담당자가 1명 이상이 되기 때문에, 누구라도 해당 업무 처리가 가능, 그리고 팀으로서 해당 업무만이 아니라 전체 제품에 대해서 함께 고민하고 개발 가능 (특정한 팀원 만이 가능한 일이 줄어들게 되고 업무에 대한 병목 감소 가능)
  - 팀원 스타일에 대한 이해도 증가
- 단점
  - 생산성 저하
  - 네비게이터와 드라이버 간의 비중 문제
  - 스타일이 맞지 않을 때 발생하는 감정적인 문제
  - 업무 피로도 증가 (대화 + 개발)
- 결론
  - 팀의 성장을 위해서는 좋은 선택이나 업무 스타일이나 성향이 서로 맞지 않는다면 좋지 않은 선택

#### 폭포수 개발 방식 특징 설명

- 개발 과정
  - 요구사항 분석
  - 소프트웨어 아키텍쳐 설계
  - 소프트웨어 구현
  - 소프트웨어 검증
  - 유지 보수
- 이전 단계가 완료되기 전에는 다음 단계로 넘어가는 것이 불가능
- 위의 개발 과정을 순차적으로 진행

#### 함수형 프로그래밍 설명

- 순수 함수를 조합하여 프로그램을 개발하는 방식
- 입력 매개변수에만 의존하여 Side-Effect를 발생시키지 않는 함수
- 인자와 반환값이 핵심 요소
- 프로그램 유지 / 관리 용이
- 선언형 프로그래밍
  - 어떻게 보다는 무엇을 할 것인지에 중점
  - 반복문 => map으로 대체
- 데이터는 불변한 것으로 간주
  - 함수 밖에 있는 데이터 변경하지 않음
  - 함수 반환값은 함수 내에서 수행된 작업을 반영
  - 함수 내부 동작으로 인한 외부의 변수가 변경되는 것을 예방

#### 회귀 테스트 (Regression Testing)

- 회귀 버그
  - 이전에 제대로 작동하던 소프트웨어 기능에 문제가 생기는 것을 의미
- 회귀 테스트
  - 기능 추가 / 오류 수정한 소프트웨어가 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 시험
  - 목적
    - 수정 부분이 소프트웨어의 다른 부분에 영향을 미치는지 테스트하여 소프트웨어 수정이 새로운 오류를 발생시키지 않았는지 확인하기 위한 목적

## 소프트웨어 공학 전반 요약 선 정리

- 소프트웨어
  - 하드웨어를 동작시켜 작업을 편리하게 수행하도록 하는 프로그램
  - 특징
    - 상품성, 견고성, 복잡성, 순응성, 비가시성, 비마모성, 비제조성, 비과학성

- 시스템 구성 요소
  - 입력, 처리, 제어, 피드백으로 이루어짐

- 소프트웨어 위기
  - 소프트웨어 개발 속도가 하드웨어 개발 속도를 따라가지 못해 사용자의 요구사항을 처리할 수 없는 문제가 발생한 것을 의미
  - 원인
    - 특성에 대한 이해 부족
    - 관리 부재
    - 프로그래밍만 치중
    - 기술에 대한 교육 부족
  - 결과
    - 인력 부족과 인건비 상승
    - 성능 및 신뢰성 부족
    - 유지보수가 어렵고 이에 따른 비용 증가
    - 생산성 저하, 소프트웨어의 품질 저하

- 소프트웨어 공학의 개념
  - 소프트웨어 위기를 극복하기 위한 방안으로 소프트웨어의 품질과 생산성 향상을 목적으로 함
  - IEEE 표준 용어사전
    - 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 방안
  - Fairley
    - 한정된 비용과 기간 내에 소프트웨어를 생산하고 유지보수하는 데 관련된 기술적이고 관리적인 원리
  - Boehm
    - 과학적 지식을 소프트웨어 설계와 제작이 응용한 것으로 개발, 운용, 유지보수하는 데 필요한 문서 작성 과정

- 소프트웨어 공학의 기본 원칙
  - 프로그래밍 기술을 계속적으로 적용해야 한다.
  - 품질이 유지되도록 지속적으로 검증해야 한다.
  - 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.

- 일반적인 소프트웨어 생명 주기
  - 정의 단계
    - 무엇을 처리하는 소프트웨어를 개발할 것인지 정의하는 단계
  - 타당성 검토 단계, 계발 계획 단계, 요구사항 분석 단계
  - 개발 단계
    - 어떻게에 초점을 두고 실제적으로 소프트웨어를 개발하는 단계
  - 설계 단계, 구현 단계, 테스트 단계
  - 유지보수 단계
    - 가장 많은 시간과 비용이 투입되는 단계로 여러 환경 변화에 따라 소프트웨어를 적응 및 유지시키는 단계

- 소프트웨어 생명 주기 모형(폭포수 모형)
  - 개발 각 단계를 확실히 매듭짓고 다음 단계로 넘어가는 방식이며 전 단계로 되돌아갈 수 없다.(선형 순차적)
  - 공학에서 가장 오래되고 고전적인 생명 주기
  - 단계별 정의가 분명하고 전체 공조의 이해가 용이함
  - 단계별 산출물이 정확하여 개발 공정의 기준점을 잘 제시함
  - 개발 순서
    - 타당성 검토    >    계획    >    요구 분석    >    설계    >    구현    >    시험    >    유지보수

- 소프트웨어 생명 주기 모형(프로토타입 모형)
  - 사용자 요구사항을 정확히 파악하기 위해 견본품을 만들어 최종 결과들을 예측하는 모형
  - 생명주기에서 유지보수 단계가 없어지고 개발 단계 안에서 유지보수가 이루어짐
  - 개발 순서
    - 요구 수집    >    빠른 설계    >    프로토타입 구축    >    고객 평가    >    프로토타입 조정    >    구현

- 소프트웨어 생명 주기 모형(나선형 모형)
  - Boehm이 제안한 것으로 폭포수와 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
  - 나선을 따라 돌 듯이 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것
  - 개발에 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 둔다.
  - 개발 순서
    - 계획 및 정의    >    위험 분석    >    공학적 개발    >    고객 평가

  - 프로젝트 관리
    - 주어진 기간 내 최소의 비용으로 사용자를 만족시키는 시스템을 개발하는 전반적인 활동
    - 효과적인 프로젝트 관리를 위한 3대 요소
    - 사람,    문제,    프로세스

- 프로젝트 비용 결정 요소
  - 프로젝트 요소
    - 제품의 복잡도 시스템의 크기 요구되는 신뢰도
  - 자원 요소
    - 인적 자원, 하드웨어 자원, 소프트웨어 자원
  - 생산성 요소
    - 개발자의 능력, 경험, 주어진 개발 기간

- 비용 산정 기법(LOC 기법)
  - 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
    - 예측치 = (a+4m+b)/6 (a=낙관치, b=비관치, m=중간치(기대치))
  - 공식
    - 노력(인월)
      - 개발기간 x 투입 인원
    - LOC / 1인당 월평균 생상 코드라인 수
      - 개발 비용
        - 노력(인월) x 단위 비용(1인당 월평균 인건비)
      - 개발 기간
        - 노력(인월) / 투입 인원
      - 생산성
        - LOC / 노력(인월)

- 비용 산정 기법(COCOMO)
  - Boehm이 제안한 것으로 원시 프로그램의 규모에 의한 비용 산정 기법이다.
  - 개발 유형
    - 조작형
      - 중 소규모의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용등 5만(50KDSI)라인 이하의 소프트웨어를 개발하는 유형
    - 반분리형
      - 조직형과 내장형의 중간형으로 트랜잭션 처리시스템이나 운영체제 등 30만(300KDSI)라인 이하의 소프트웨어를 개발하는 유형
    - 내장형
      - 초대형 규모 트랜잭션 처리 시스템이나 운영체제 등 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형

- COCOMO 모형의 종류
  - 기본형
    - 소프트웨어 크기와 개발 유형만을 이용하여 비용을 산정하는 모형
  - 중간형
    - 기본 공식을 토대로 사용하나 제품 특성, 컴퓨터 특성, 개발 요원의 특성, 프로젝트 특성에 의해 비용을 산정하는 모형
  - 발전형
    - 중간형을 보완하여 만들어진 방법으로 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용을 산정하는 모형

- 브록스의 법칙
  - 프로젝트 진행중에 새로운 인력을 투입할 경우 적응 기간과 부작용으로 인해 일정을 더욱 지연시키고 프로젝트에 혼란을 가져오게 된다는 법칙

- PERT/CPM
  - 프로젝트 지연을 방지하고 일정을 계획하는 것으로 자원의 제약하에 비용을 적게 사용하면서 최단시간 완성을 위한 프로젝트 일정 방법
  - 개발 기간을 결정하는 임계 경로(CP)를 제공한다.
  - 통계적 모델을 적용해서 개별 작업에 대한 가장 근접한 시간 측정의 기준이 된다.

- PERT
  - 노드와 간선으로 구성되며 원 노드에는 작업을 간선에는 낙관치, 기대치, 비관치를 표시
  - 전체 작업의 상호 관계를 표시하는 네트워크로 단계별 종료 시기를 결정하는 방법

- CPM
  - 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소유 기간을 예측하는데 사용하는 기법
  - 노드와 간선으로 구성된 네트워크로 노드는 작업을 간선은 작업 사이의 전후 의존 관계를 나타냄
  - 원형 노드는 각 작업을 의미하며 각 작업의 이름과 소유기간을 표시하고 박스 노드는 이정표를 의미하며 박스 노드 위에는 예상 완료 시간을 표시함

- 간트차트
  - 프로젝트의 각 자억들이 언제 시작하고 종료되었는지 막대 도표를 이용하여 표시하는 프로젝트 일정표로 시간선 차트라고도 한다.

- 프로젝트 팀 구성
  - 분산형 팀
    - 팀원 모두가 의사 결정에 참여하는 비이기적인 구성 방식
    - 의사소통 경로의 수 = (n(n-1))/2 (n은 팀원의 수)
  - 중앙 집중형 팀
    - 한 관리자가 의사결정 하고 구성원들은 그 결정을 따라는 구성 방식으로 책임 프로그래머 팀이라고도 함
  - 계층 적팀
    - 분산형 팀 구성과 중앙 집중형 팀 구성을 혼합한 형태
    - 5~7명의 초보 프로그래머를 작은 그룹으로 만들어 각 그룹을 고급 프로그래머가 관리하게 함

- 품질 표준
  - 명확하게 정의된 소프트웨어의 특성을 의미하며 품질을 평가하는 기준 항목
  - 종류
    - 정확성, 신뢰성, 효율성, 무결성, 사용 용이성, 유지보수성, 유연성, 시험 역량, 이식성, 재사용성, 상호 운용성

- 위험 관리
  - 프로젝트 개발 과정에서 각종 돌발 상황을 미리 예상하고 적절한 대책을 수립하는 일련의 활동

- 형상 관리(SCM)
  - 개발 과정에서 소프트웨어의 생산물을 확인하고 소프트웨어 통제, 변경 상태를 기록하고 보관하는 일련의 관리 작업
  - 소프트웨어 변경의 원인을 알아내고 제어하며 적절히 변경되었는지 확인하여 담당자에게 통보하는 작업
  - 개발의 전 단계에 적용되는 활동으로 유지보수 단계에서 수행된다.
  - 개발의 전체 비용을 줄이고 개발 과정의 문제점을 해결하여 방해 요인을 최소화하는 것을 목적으로 한다.

- 요구사항 분석의 어려움
  - 사용자와 개발자의 지식 배경의 다양화 용어 불일치 등으로 의사소통 곤란
  - 난이도 증가에 의한 소프트웨어의 복잡화
  - 사용자 생각의 부정확성, 생각의 반복된 변경
  - 애매하거나 어렵거나등 요구 명세서 작성이 어려움

- 자료 흐름도(DFD, 버블차트) 
  - 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 버블 차트라고도 함
  - 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용된다.
  - 자료 흐름도는 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화된다.
  - 단계 0의 자료 흐름도를 배경도라 하는데 이 배경도를 통해 전체 시스템의 범위를 표현한다.
  - 각 프로세스에 대하여 개별적인 상세화 및 계층화가 가능하다.

- 자료사전(DD)
  - 자료 흐름도 상에 있는 자료를 더 자세히 정의하고 기록한 것이며 데이터를 설명하는 데이터를 데이터 또는 메타데이터라고 한다.

- 자료 사전 표기 기호
  - =      자료의 정의
  - '+'      자료의 연결
  - ()      자료의 생략
  - |        자료의 선택
  - {}       자료의 반복
  - **     자료의 설명

- HIPO
  - HIPO (Hierarchy plus Input-Process-Output)
  - 소프트웨어 설계 및 분석에서 사용되는 문서화 기법으로, 시스템의 계층적 구조와 데이터 흐름을 시각적으로 표현하는 방식
  - 소프트웨어 개발 초기 단계에서 설계 내용을 명확히 전달하고, 시스템의 작동 방식을 이해하기 쉽게 하기 위해 주로 사용
  - 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로 입력, 처리, 출력의 기능을 나타낸다.
  - 하향식 소프트웨어 개발을 위한 문서화 도구
  - 체계적 문서 관리가 가능하고, 기호, 도표 등을 사용하므로 보기 쉽고 이해가 쉽다.

- HIPO의 종류
  - 가시적 도표 (도식 목차)
    - 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조도
  - 총제적 도표 (총괄 도표)
    - 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
  - 세부적 도표 (상세 도표)
    - 총제적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술한 도표

- 결합도(Coupling)
  - 모듈 간에 상호 의존도를 나타낸다.
  - 독립적인 모듈이 되기 위해서는 모듈 간의 결합도가 약해야 하며 의존하는 모듈이 적어야 함

- 결합도의 종류
  - 자료 결합도
    - 모듈 간의 인터페이스가 자료 요소로만 구성될떄의 결합도
  - 스탬프 결합도
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 떄의 결합도
  - 제어 결합도
    - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어요소를 전달하는 결합도
  - 외부 결합도
    - 어떤 모듈에서 외부로 선언한 데이터를 다른 모듈에서 참조할 떄의 결합도
  - 공통 결합도
    - 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  - 내용 결합도
    - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 떄의 결합도

- 응집도(Cohesion)
  - 정보 은닉 개념을 확장한 것으로 모듈이 독립적인 기능으로 정의되어 있는 정도를 나타냄
  - 내부 요소에는 명령어, 명령어의 모임, 호출문 등이 있음
  - 독립적인 모듈이 되기 위해서는 각 모듈의 응집도가 강해야 함

- 응집도 종류
  - 기능적 응집도
    - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
  - 순차적 응집도
    - 모듈 내의 하나의 활동으로부터 나온 출력데이터를 다음 활동의 입력 데이터로 사용할 경우의 응집도
  - 교환적 응집도
    - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모여 있을 경우의 응집도
  - 절차적 응집도
    - 모듈이 다수의 관련 기능을 가질 떄 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
  - 시간적 응집도
    - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
  - 논리적 응집도
    - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
  - 우연적 응집도
    - 모듈 내부의 각 구성 요소들이 서로 관련 없는 다른 기능을 수행하는 경우의 응집도

- 효과적인 모듈화 설계 방안
  - 결합도를 줄이고 응집도는 높여서 모듈의 독립성을 높인다.
  - 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
  - 유지보수가 용이해야 한다.
  - 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
  - 하나의 입구와 하나의 출구를 갖도록 한다.

- Nassi-Schneiderman Chart (나씨 슈나이더만 도표)
  - 논리의 기술에 중점을 둔 도형을 이용한 표현 방법
  - 순차 구조, 반복 구조, 선택 구조, 다중 선택 구종 등으로 표현
  - GOTO나 화살표를 사용하지 않으며, 선택과 반복 구조를 시각적으로 표현한다.
  - 이해하기 쉽고 코드 변환이 용이하다
  - 읽기는 쉽지만 작성하기 어려우며 임의로 제어를 전이하는 것이 불가능하다.

- 구조적 프로그래밍
  - 다익스트라(Dijkstra)에 의해 제안된 것으로 소프트웨어의 생산과 코딩의 표준화 등을 위해 개발된 방법이다.
  - 제어 구조
    - 순차: 명령을 순서적으로 나열함
    - 선택: 특정 논리에 기초하여 명령을 선택함
    - 반복: 순환을 제공함

- 화이트 박스 테스트
  - 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 검사하여 검사 사례를 설계하는 방법
  - 모듈 안의 작동을 직접 관찰할 수 있으며 원시 코드의 모든 문장을 한번 이상 수행함으로써 수행된다.

- 화이트 박스 테스트 종류
  - 기초 경로 검사
    - Tom McCabe게 제안한 것으로 대표적인 화이트 박스 테스트 기법
    - 검사 사례 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주고 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용됨
  - 조건 검사
    - 모듈 내에 있는 논리적 조건을 검사하는 검사 사례 설계 기법
  - 루프 검사
    - 반복 구조에 초점을 맞춰 실시하는 검사 사례 설계 기법
  - 데이터 흐름 검사
    - 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 검사 사례 설계 기법

- 제어 흐름도
  - 제어 흐름을 표현하기 위해 사용되는 그래프

- 순한 복잡도
  - 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도로 제어 흐름도 이론에 기초를 둠
  - 순환 복잡도 계산
    - 화살표 - 노드 수 + 2 = 순한 복잡도

- 블랙 박스 테스트
  - 소프트웨어의 각 기능이 완전히 작동되는 것을 입증하는 검사로 기능검사라고도 한다.

- 블랙 박스 테스트의 종류
  - 동치 분할 검사
    - 입력 자로에 초점을 맞춰 검사 사례를 만들고 검사하는 방법
  - 경계값 분석
    - 동치 분할 기법을 보완하기 위한 기법으로 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 검사 사례로 선정하여 검사
  - 원인-효과 그래프 검사
    - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성 높은 검사 사례를 선정하여 검사하는 기법
  - 오류 예측 검사
    - 과거의 경험이나 확인자의 감각으로 검사하는 기법
  - 비교 검사
    - 여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는지 검사하는 기법

- 단위 검사
  - 코딩이 이루어진 후 최소 단위인 모듈에 초점을 맞추어 검사하는 것

- 하향식 통합 검사
  - 상위 모듈에서 하위 모듈 방향으로 통합하면서 검사하는 기법

- 상향식 통합 검사
  - 하위 모듈에서 상위 모듈 방향으로 통합하면서 검사하는 기법

- 검증 검사
  - 소프트웨어가 사용자의 요구사항을 충족시키는가에 중점을 두고 검사하는 기법

- 검증 검사의 종류
  - 형상 검사
    - 소프트웨어 구성 요소, 목록, 유지보수를 지원하기 위해 필요한 모든 사항들이 제데로 표현되었는지를 검사하는 기법
  - 알파 검사
    - 개발자의 장소에서 사용자가 개발자 앞에서 행하는 검사 기법
  - 베타 검사
    - 선정된 최종 사용자가 여러 명의 사용자 앞에서 수행하는 검사 기법

- 시스템 검사
  - 개발된 소프트웨어가 시스템에서 완벽하게 수행되는가를 검사하는 것
  - 종류
    - 복구 검사, 보안 검사, 강도 검사, 성능 검사

- 디버깅
  - 검사 단계에서 검사 사례에 의해 오류를 찾은 후 그 오류를 수정하는 과정

- 객체지향 기법
  - 현실의 기계 부품처럼 하나의 객체로 만들어 부품으로 기계를 조립하는 것처럼 객체를 조립해서 작성할 수 있도록 하는 기법
  - 유지 보수가 쉬우며 재사용 및 확장이 용이해 소프트웨어를 빠르게 개발할 수 있다.

- 객체지향 기법의 구성 요소
  - 객체
    - 데이터와 함수 기능을 가지고 있음
  - 클래스
    - 객체의 집합으로 객체의 일반적인 타입을 의미
  - 메시지
    - 객체들 간의 상호작용을 하는데 사용되는 수단으로 객체에게 어떤 행위를 하도록 지시하는 명령

- 객체지향 기법의 주요 기본 원칙
  - 캡슐화
    - 데이터와 데이터를 처리하는 함수를 하나로 묶는 것
    - 객체들의 재사용이 용이함
    - 인터페이스가 단순해지고 객체간의 결합도가 낮아짐
  - 정보 은닉
    - 캡슐화에서 가장 중요한 개념으로 다른 객체에 자신의 정보를 숨기고 연산만을 통하여 접근을 혀용하는 것
  - 상속성
    - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는것
  - 추상화
    - 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화하는 것
  - 다형성
    - 메시지에 의해 객체가 연산을 수행하게 될때 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

- 객체지향 분석 방법론
  - Rumbaugh 방법
    - 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법
  - Booch 방법
    - 미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법으로 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
  - Jacobson 방법
    - Use Case를 강조하여 사용하는 분석 방법
  - Coad와 Yourdon 방법
    - E-R다이어그램을 사용하여 객체의 행위를 모델링하며 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
  - Wirfs-Brock 방법
    - 분석과 설계간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법

- Rumbaugh 분석 기법
  - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
  - 분석 활동은 객체 모델링, 동적 모델링, 기능 모델링순으로 이루어진다.

- 객체지향 설계 단계
  - 문제정의    >    요구 명세화    >    객체연산자 정의    >    객체 인터페이스 결정    >    객체 구현

- 소프트웨어의 재사용
  - 이미 개발된 소프트웨어의 전체 혹은 일부분을 다른 소프트웨어에 사용하는 것
  - 개발의 품질과 생산성을 높이기 위한 방법

- 소프트웨어 재공학
  - 기존 소프트웨어를 파기하지 않고 새로운 요구에 맞도록 수정 보안하거나 새로운 기능을 추가하여 성능을 향상시키는 것
  - 유지보수 비용이 개발 비용의 대부분을 차지하는 문제를 고려하여 개조 및 개선을 통해 유지보수성과 품질을 향상시키려는 기술
  - 유지보수 생산성 향상을 통해 소프트웨어 위기를 해결하는 방법

- 소프트웨어 역공학
  - 기존 소프트웨어를 분석하여 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업
  - 목표
    - 복잡한 시스템을 다루는 방법 구현
    - 다른 뷰의 생성
    - 잃어버린 정보의 복구 및 제거
    - 부작용의 발견

- CASE
  - 개발 과정에서 사용되는 요구분석, 설계구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것
  - 소프트웨어 생명 주기의 전체 단계를 연결해 주고 자동화해주는 통합된 도구를 제공해주는 기술
  - 주요기능
    - 소프트웨어 생명주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원등
  - 이점
    - 개발 기간 단축 및 비용 절감, 품질 향상, 유지보수 용이, 생산성 향상, 재사용성 향상, 개발주기의 표준화 등

- CASE 분류
  - Upper CASE
    - 생명 주기의 전반부에 사용되는 것으로 문제를 기술하고 계획하며 요구 분석과 설계 단계를 지원하는 CASE
  - Lower CASE
    - 생명주기 하반부에 사용되는 것으로 코드의 작성과 테스트 문서화하는 과정을 지원하는 CASE
  - Intergrate CASE
    - 생명주기에 포함되는 전체 과정을 지원하기 위한 CASE

- CASE 정보 저장소
  - 소프트웨어를 개발하는 동안에 모아진 정보를 보관하여 관리하는 곳으로 오늘날에는 데이터베이스가 정보 저장소 역할을 담당

## 소프트웨어 공학 범위

전체범위 4가지중 소프트웨어 공학
- 소프트웨어 공학
  1. 방법론: OOP, UML(UseCase, Class, Sequence, Component, Deployment)
  2. 프로젝트 관리: RFP 범위, WBS(구조), 일정 (일의 순서, PND), 비용
  3. 품질
- 데이터베이스
- 정보보안
- IT 경영

## 소프트웨어 공학 정의 / 문제 사례

- 소프트웨어 공학
  - 소프트웨어 문제점을 체계적으로 해결하기 위한 방법
- 소프트웨어 위기 극복을 위한 대안
- 소프트웨어 Re-engineering
  - Reverse engineering, Re-structure
- 대표적인 위기/문제 사례
  - 비용 증가 (예측, Budget이 정확한가)
  - 생산성 (규모와 노력, 노력의 정도)
  - 일정 지연 (진행 과정, 개념 증명, 변경, 표준화된 툴(간트차트 등))
  - 품질 저하 (주관, 변화, 측정) : 주관적이고 시간에 따라 변화
- 복잡한 시스템
  - 규모
  - 인터페이스
  - 알고리즘 (기능 동일한데 복잡한 알고리즘, 효율적이지 않은데 복잡한 코드, 알고리즘 문제)
- 재사용의 크기
  - 너무 크면 인터페이스는 줄어듬
  - 재사용율은 떨어짐
  - 독립적인 단위/부품 => 컴포넌트

## 프로세스 모델

- 소프트웨어 방법론에 대한 추상화된 형태
  - 계획, 발주/계약, 사업착수, 계획, 실행
  - 요구사항, 분석, 설계, 구현, 테스트
- 모델 종류
  - 폭포수: 순차적
  - 프로토타이핑: 요구사항 확인
  - 반복형: 요구사항 ~ 테스트 반복
  - 점진형: 버전 추가하듯이 개발 (새로운 기능 추가하듯이 개발)
  - 나선형: 반복적 위험 분석/평가
  - 빅뱅: 작은 위험 (이전 프로젝트의 산출물을 어느정도 재사용 가능한 상황 등)
  - 애자일: 경량화, 작은 단위 개발

## 방법론

- 개발을 위한 구체적인 모든 것을 포함하고 있는 방법
  - 절차, 산출물, 도구 등
- 방법론 종류
  - 구조적: 기능(모듈) 단위
  - 정보공학: 데이터 중심, Integration (통합) -> 표준화 -> 데이터 표준화, 데이터를 표준화해서 통합한다는 개념
  - 객체: 데이터 + 메소드 (오퍼레이션) 결합
  - 컴포넌트: 독립적인 실행 단위
  - Product Line: 업무 공통 컴포넌트, Core Asset
  - SoD (SoA): 업무 로직
  - 6 Sigma 개발 (DMAIC): 정량적 품질 관리, 고객중심의 정량적 품질 관리
  - TDD: 코드 전 테스트 설계, 테스트 가능한 프로그램 제작, Unit 테스트에 포커스
  - BDD: 행위 주도 개발 (Behavior Driven Development)
    - TDD 근간으로 파생된 개발 방법
    - 테스트 케이스 자체가 요구사양이 되도록 하는 개발 방법
  - BDD 기본 패턴
    - 시나리오 기반으로 테스트 케이스 작성, 일반 사람이 봐도 이해할 수 있는 정도의 레벨 권장
    - Feature: 테스트에 대상의 기능/책임 명시
    - Scenario: 테스트 목적에 대한 상황 설명
    - Given: 시나리오 진행에 필요한 값 설정
    - When: 시나리오 진행에 필요한 조건 명시
    - Then: 시나리오 완료 시 보장해야 하는 결과 명시
  - Scrum: 팀 활동, 팀은 어떻게 조직화 시키고 각자의 업무는 무엇인가에 포커스
  - XP: 빠른 피드백, 빠르게 가치 제공
  - Kanban: 작업량 제한
  - Lean: 낭비 제거

## Process Management

- 소프트웨어 작업의 흐름 체계화
  - Input, Tools, Output
- Product가 아닌 Process에 포커스

  | ISO9000 | Cmmi    |
  | ------- | ------- |
  | 제품 규격, 프로세스 | 소프트웨어 개발에 대한 프로세스|

- QA, QC

## SDLC (개발 생명주기)

- SDLC 표준 : ISO 1207
- Software Development Life Cycle
- 소프트웨어 탄생부터 소멸까지의 과정
  - 계획, 발주, 제안, 계약, 사업관리, 개발, 검수, 유지보수 (하자, 유상보수)
- 모형화
- SDLC 과정
  - 타당성 검토
    - 소프트웨어 사업의 추진여부를 결정하기 위해 사전에 검토하는 것
    - 기대손실, RoI, NPV (Net Present Value), IRR (Internal Rate of Return), 기술력, 가용성, 현재 여유 인력
  - 요구사항 정의: 범위, 기능적, 비기능적 (품질 요구 사항, 암시적, 명시적)
    - 명시적 요구사항: 개발보안 (Secure Coding), 웹 취약점 검사, 웹 호환성, 웹 접근성 (일반인, 장애인 차별없는 서비스 제공), 개인정보, 성능
    - 암시적 요구사항: 핵심인력 활용한 개발, 변경 최소화, 사용자 맞춤형, 원래는 명시적 요구사항에 포함되었어야 하는 항목들인데 여러 상황으로 빠지거나 늦게 추가된 것들
  - 설계
  - 개발
  - 이행: 배포
- SDLC 모델 종류
  - 폭포수 모델
    - 간단, 순차적, 검증 Verification 후 다음 단계, Verfication 은 기능 관점
    - 요구사항 확인 어려움
    - Validation 은 행위관점, 고객 관점, 요구사항 확인 어려움, 중간중간 확인 어려움
  - 프로토타이핑
    - 시제품 개발, 확인, 이해관계자들에게 확인
    - 종류: 실험적, 진화적, 수직형, 수평형 모델
    - MM 낭비, 제안전략, 개념증명, 단계별 투입 인력, Validation, BDD
  - 증분 모델
    - 버전 추가 방식, 버전 단위, 핵심 요구사항, 개발하며 통합, 반복, 
    - 요구사항/분석/설계를 반복, 반복 단계별 산출물이 무엇인지 정의 필요하며 정의가 되어야 반복 가능
    - BaseLine (고객에게 승인된 산출물)
  - 진화적 모델: 반복형 점진형 모델, PMO, 포트폴리오, 조직에 목적과 맞는 소프트웨어 관리
  - 나선형 모델: 폭포수 + 프로토타입, 아키텍쳐, 통합, 대규모 프로젝트 적합
  - RAD (Rapid Application Development)
    - 위험 적고 Reuse Component 사용, 빠른 개발, 컴포넌트 재사용 > 단기간에 소프트웨어 개발하는 방법
    - JRP (Joint Requirement Planning), JAD(Joint Application Design) 고객과 함께

## 요구사항 분석

- 과업의 범위 확인, RFI
- RFP
  - 목적, 사업의 범위, 추진 계획, 일정, 핵심 요구사항, 분류, 선택, 비기능적, 사업관리 요구사항
  - 프로젝트 요구사항, 보안, 보고시점 (마일스톤), 인력, 입찰, 조건/방법, 기능 점수, 제안 평가
- 제안서 
  - 사업 목적 / 이해, CSF, 통합, 
  - 제안전략 (외부 전문가 활용한 개녕, 프로토타입 통한 사전검증, 인력, 유사 사태), 
  - 실행방안, 기대효과, 기술부분, 사용관리, 제안업체 소개, 재무재표
- 기술협상
- 착수 PMBOK
- 공식 시작
- PM에게 권한 허가
- Planning
- 사업수행계획서(프로젝트 관리 계획서)
  - PM은 검수의 기준으로 바라보아야 한다.(과업 이행의 점검 기준)
  - 범위(WBS, 진척률), 과업대비표(진척률), 일정, 투입 인력, 단계별 산출물, 방법론, 검수기준
  - 진척률에 대한 검수와 확인 필요 (기준 필요)
  - Baseline, PM이 임의로 변경하면 안됨, 고객과 승인된 내용, 도장찍은 협의된 내용
  - Baseline 만들어지고 나면 변경 관리 필요
- 범위, 일정
- 비용
- 요구사항 수집 출처
  - RFP: 기능 및 비기능
  - 제안서: 기술부분, 지원부분, 추가제안(애매한 제안)
  - 기술협상: RFP와 제안서 상 명확하지 않은 요구사항 검토
  - 핵심 이해관계자: 핵심 질문(Key Question), 서브 질문, 질의서 작성 필요, 이해관계자만의 요구사항 확인(동적 요구사항)
- 요구사항 정의서 (엑셀 목록)
  - 구체적이지는 않으나 완전성 목적(빠진것 없어야 함), 우선순위 협의
  - ID, 명, 설명, 중요도, 난이도, 우선순위, 이해관계자, 현행 시스템 여부(신규/개선/이관), 수용여부
- 명세서 (유스케이스 리포트)
  - 요구사항 정의서 내 작성된 설명의 상세화, 세분화
- 요구공학
  - 정의: 요구사항 문제를 체계적으로 해결하기 위한 방법
  - 식별, 분석, 명세, 검증: 요구사항 개발
  - 요구사항 개발 프로세스 (식별, 정의, 명세, 확인)
    - 식별: RFP 요구사항 식별
    - 정의: 수용/거부
    - 명세: 유스케이스 다이어그램, 명세서
    - 확인: 프로토타입과 Inspection
  - 유지보수: 요구사항 관리 (변경 관리, Cmmi)
- 요구사항 원칙
  - 완전성: 시스템 구현에 필요한 모든 것 표현, RFP에 모든 요구사항을 포함하라.
  - 명확성:
    - 모든 엔티티와 애트리뷰트는 단 한가지로만 해석되어져야 함
    - 도메인 용어 정의, 업무 용어 정의, 나눠질 수 없는 단위로 해석이 되어야 함
  - 일관성: 요구사항들 간의 충돌 없어야 함 > 요구사항 그룹핑 필요 (PM 역할)
  - 추적성
    - 요구사항 분석 설계를 추적 관리, 과업대비표, 과업 추적, 과업대비표를 해야한다.
    - 모든 사용자의 로그인부터의 행위는 기록되고 관리되어야 함, 상호 맵핑되고 관리 필요
    - 탑 다운의 의사결정 내용은 관리자, 실무자까지 추적되고 통제되야 함
- 요구공학 프로세스
  - 요구사항 및 시스템 범위: 연계대상, 미확정 리스트, 엔드 유저
  - 요구사항 정의: 선행조건, 후행조건, 액터 (유스케이스를 실행하는 사람/시스템, 이벤트를 발생시키는 주체)
    - 액터는 모델링의 대상이 아님, System Boundary 밖에 있음, 연관, 상속 등의 화살표로 표시
    - 스테레오 타입(사용자 정의 타입), include, extend
  - 요구사항 명세화: 유스케이스 아이디/이름
  - 테스트 시나리오(케이스)
- 요구사항 확인
  - Walkthrough, Inspection 등
    - 체크리스트 기반한 점검 (주석, 함수명, 파라미터 규칙 관련 체크리스트)
  - 사전에 오류/결함 제거
    - 동료 검토 기법
    - 품질 보증 기법
  - Review: 자유롭게 검토, 서로 의견 공유
  - 요구사항 관리 문제점
    - 업무에 대한 이해 부족, 업무 범위 변경, 일정 및 자원부족, 의사소통, 명세화 부족
    - 변경, 도메인, 의사소통

## 공식적인 활동 측면에서 Inspection 과 Walkthrough

- Walkthrough
  - 주제, 체크리스트를 가지고 점검하는 도중에 심각한 이슈 발생 시 중단하고 주제 변경 가능
- Inspection
  - 어떤 주제를 끝내고 다른 주제의 Inspection으로 이어간다
- Review
  - 자율성 고려한 검토

## 요구사항 문제점

- (공공, 전자정부 사업, 금융권 시스템 등) 요구사항의 문제점
  - 도메인 용어 정의 필요 (현재가, 체결가, 시세는 같은 의미를 가지고 있으므로 공통용어, 용어에 대한 정의 선행 필요)
    - 업무가 복잡하거나 다국어 프로젝트 진행 시에 해당
    - 정의가 안되면 업무 이해가 어려움
  - 업무에 대한 이해: 현업 담당자도 자신의 담당 업무만 이해하고 있는 문제
  - 변경 여부: 변경에 대한 판단 기준 합의 (왜 발생하고 변경 발생이 받아들여질 수 있는지를 사전에 합의)
    - 변경 분류를 통한 영향도 분석 필수, 변경 유발 요인 분석(현업 조직 변경 / 업무 또는 제도 변경)
    - 업무 / 제도 변경: 신규 상품 파생, 개인정보보호법 등, 요구사항 수립 때 사전에 선을 긋는 것이 중요
    - 무결성/추적성: 누가 요청을 했고 언제 배포했고 등의 히스토리 정리 필요
  - 커뮤니케이션과 조직 문제
    - 사용자 - 개발자 간 직접적인 소통, 대규모 프로젝트에서는 적합하지 않음
    - 유지보수 사업 때 문제, 개발자, PMO간의 혼란, 관리자 통하지 않으므로 소통 혼란 야기
  - 인지편견/편향 문제 (인지 터널, 착각)
    - Cognitive bias: 경험에 의한 비논리적 추론으로 잘못된 판단을 하는 것 의미
  
## 방법론

- 원칙:
  - 추상화:
    - 책의 목차 생각, 간략하게 표현한다는 의미
    - 공통을 식별해서 중복을 방지, 데이터/Procedure(Function) 추상화가 있음  
  - 정보은닉: 중요 데이터에 대해 직접 참조 제한 (접근 지정자 - public, private, protected)
  - 모듈화
    - 독립된 단위로 구성
    - 평가 기준: 결합도, 응집도
    - 상속은 높은 결합도, 결합도가 낮다고 좋은 것이 아님
  - 상속
    - 부모의 특성을 자식이 물려받음
    - 트리의 너비와 깊이가 넓어지면 질수록 복잡성 증대하나 확장성/재사용성 좋음
  - 캡슐화
    - 애트리뷰트(데이터)와 메소드(오퍼레이션)가 결합된 클래스로 표현
    - 캡슐화는 접근 지정자를 제공해 줌
- 모델링:
  - 유스케이스 다이어그램(사용자 관점)
  - 클래스 다이어그램(논리적인 구조, 프로그램 내부)
  - 시퀀스 다이어그램(동적 흐름)
  - 컴포넌트 다이어그램
  - 디플로이먼트 다이어그램
- 아키텍쳐 스타일(패턴): 클라이언트-서버
- 패턴:
  - GRASP (낮은 결합도와 높은 응집도를 지켜야 함)
    - General Responsibility Assignment Software Patterns
  - 디자인 패턴 (설계 문제에 대한 해결책)

## 리팩토링

- 외부 기능은 변경하지 않고 내부 기능을 개선하는 것
  - 가독성 증대, 성능 개선 목적
- 반복적으로 지속적으로 행해져야 하는 활동, 일회성 X

## 소프트웨어 아키텍쳐 - 정보시스템의 구조(분류)를 확립

- 소프트웨어 아키텍쳐
  - 핵심 구성요소와 상호작용을 정의한 청사진
- 소프트웨어 아키텍쳐 기대효과
  - 의사소통, 재사용, 가이드라인
- 사전 설명
  - 구조, 분류, 공통, 의사소통
  - 공통을 먼저 식별하고 분류한다.
  - 분류는 컴포넌트, 인터페이스(I/F) 말이 항상 같이 따라옴
  - 대민시스템(민원처리, 특허정보 시스템 등), 분석시스템(빅데이터, DW)
  - 소프트웨어 아키텍처는 처음에 분류를 하는 것이 최우선
- 정보시스템의 핵심 구성요소 및 구성요소 간의 상호작용을 정의한 청사진/구조
  - 상호작용이란 회원가입>로그인, 로그인>주문가능 이런 것들
  - 상호작용: 비즈니스 업무간, 앱과 DB, 엔드유저와 정보시스템, 기술
- 아키텍처 기능
  - 프로젝트에 영향을 주는 이해당사자 간의 의사소통, 프로젝트의 키 스택 홀더(프로덕트 오너)
    - 이해당사자: 사용자, 스폰서(경제적인 부분), PM, 개발자
    - PM는 프로젝트의 키 스택 홀더가 많으면 많을수록 어려워짐
  - 설계 초기에 의사결정 기준
    - 설계>기능(완전)으로 아키텍쳐를 우선 확립 후
    - 비기능으로 성능 개선, 제안1,2 등
  - 시스템을 재사용할 있는 추상화 모델 (간단하고 공통된 모델)
    - 재사용>비즈니스>통합 가능, 재사용>앱>공통 컴포넌트
- 아키텍처 활동 (구축 절차)
  - 기능적 요구사항(RFP, 제안서, 기술협상, 키스택홀더): 시스템 구조 정의
  - 비기능적 요구사항(QA): ISO9126 등의 품질 요구사항 식별, 우선순위 결정 (유틸리티 분석 수행 - 중요도, 난이도 식별 목적)
  - 전술(전략)정의: 비기능적 요구사항 해결 방법, 측정 기준 및 방법
  - 재사용 컴포넌트: 재사용 / 공통 컴포넌트를 정의
  - 아키텍쳐 계층화: 레이어 계층을 정의, 인터페이스 식별 (OSI 7계층도 레이어 계층)
  - 뷰 포인트: 각자의 관점별로 이해할 수 있는 방법으로 제시할 것 (사용자, 분석/설계자, 개발자 등)
    - 소프트웨어 아키텍쳐 보고서 (IEEE1471)
  - 품질속성(비기능적 요구사항)
    - 품질속성 종류: 시스템, 비즈니스, 아키텍쳐
    - ISO9126(품질모델): 기능성, 사용성, 신뢰성, 효율성, 유지보수성, 이식성
      - 기능성: RFP에 나온 모든 요구사항을 만족, 완전을 준수하였는가
      - 사용성: 사용이 쉬운가, 예제 제시
      - 신뢰성: 결함이 없는가, 품질 목표가 제시가 결함율을 달성하였는가, 목표 결함률 준수 여부
      - 효율성: 제한된 자원 하에 처리량 극대화 가능한가
      - 유지보수성: 코딩이 표준화되어 있고 이해가 용이하고 주석이 있으며 모듈화가 되어있는 등
      - 이식성: 다른 환경에서 적용 가능한가, 윈도우/맥 등
  - 소프트웨어 아키텍처 평가
    - ATAM (Architecture Tradeoff Analysis Method): 아키텍쳐 품질요소 간의 상호작용 정의
    - CBAM (Cost Benefit Analysis Method)
      - 경제적 의사결정을 위한 아키텍쳐 분석의 경제적 모델링
      - 시나리오 정의, 효용/반응값, 이익계산, 아키텍처 선정 및 검증
  - 소프트웨어 아키텍처 스타일
    - MVC: 하나의 데이터를 다양한 뷰로 출력, 모델도 뷰도 확장 가능,
      - 다형성(Polymorphism), 오버로딩, 오버라이딩 2가지 유형 (컴파일/런타임 유형), 템플릿 메소드
    - Pipe Filter: 여러개 명령 동시 실행, 순차 처리와 병렬 처리 모두를 모델링
    - Layer Style
    - Repository: 공유 저장소
    - Publish Subscribe: MVC와 유사, EAI
    - Client-Server
    - Virtual Machine: Host OS, VM, VM 안의 OS (Guest OS), Vitualization, 하이퍼바이저, Docker
- 기타 작성 내용
  - 유틸리티 분석은 아래와 같음
  - 비기능적 요구사항:
    - 품질속성: 성능, 가용성(장애 시 바로 전환 등), 보안, 호환성 (이런 큰틀을 마련해준 것이 ISO9126)
    - 시나리오: 3초이내 응답, 주서버장애 시 5분 이내에 백업서버로 전환되어야 함, 전송구간은 암호화/고유식별자는 저장소 암호화, IE9이상 부터는 문제가 없어야 한다.
    - 중요도: 상
    - 난이도: 중
    - 우선순위: 상
  - 유틸리티 분석은 어떻게 평가하는가
    - 측정방법, 측정주기

## 객체지향 분석 / 설계

- 분석: 문제점 파악
- 객체지향 특성
  - 추상화:
    - 복잡>간략히 표현
    - 공통, 데이터, 기능 <-- 간략하게 표현하는 것 > 추상화 
  - 캡슐화: 속성과 연산인 클래스, 클래스가 캡슐화
    - 접근지정자 부여 가능, public, private, protected
  - 상속: 부모 클래스의 기능을 물려받음
  - 다형성: 동일한 메세지에 대해서 객체가 반응하는 특성, 동적 바인딩
- RUP 4+1 View
  - UseCase View: 사용자 요구사항 모델링, 명세
  - Logical View: 시스템 내부 (클래스) 구조 모델링
  - Process View: 프로그램, 프로세스 분할, 프로세스, 스레드 병행성, 런타임 환경
  - Implementaion View: 컴포넌트 그룹화
  - Deployment View: 서버 구성도, 컴포넌트가 노드에 배치
- BPR (Business Process Reengineering)
  - 업무 재설계하는 것을 의미
  - 유저 스토리, 내가 하는일, 시나리오(이벤트 플로우, 일하는 절차)
- 객체 지향 설계 원칙
  - 인터페이스 분리: 입출력의 인터페이스 분리, 입력 1개, 출력 1개 각각 인터페이스를 분리
  - 개방과 폐쇄: 확장은 가능, 변경되지 않은 구조 (MVC)
    - OPEN and CLOSED
    - Client 에서 sort() 호출 시 구현체에서 실제 동작함, 구현체만 증가시키면 확장 가능, 구조는 변화되지 않음
    - 호출은 연관관계, 구현은 실체화(다형성, 메소드이름을 동일하게 쓴다)
    - 전략 패턴 적용 시 다른 알고리즘 여러개 추가 가능
  - 단일책임 원칙: 모듈화 의미, 하나의 객체가 하나의 책임
  - 리스코프 치환원칙: 자식들은 부모 타입들이 사용되는 곳에 대체될 수 있어야 함.
    - 서브 클래스의 메소드로 대체될 수 있어야 함 (다형성 의미)
  - 의존관계 역전
    - 누가 누구를 종속하는가
    - 의존관계는 파생 클래스가 아닌 추상클래스

## UML

- UseCase 다이어그램
  - Actor, Usecase 상호작용 모델링
  - 액터와 유스케이스, 유스케이스와 유스케이스 간 상호작용을 가시화 할 수 있는 다이어그램
  - 유스케이스와 유스케이스간 관계
    - include: 반드시 둘중 하나 포함
    - exclude: 어떤 조건이 되야 실행
  - UseCase 명세서에 상세 내용 표기, UseCase 마다 명시
- 유스케이스 명세서
  - 액터
  - precondition(프리컨디션), 포스트컨디션
  - 시나리오 (기본, 대체, 예외 흐름)
- Class Diagram
  - 정적 모델링, 클래스 속성, 행위, 서로간의 관계 모델링 (상속, 연관, 구현, 합성 등)
  - A라는 클래스가 있을 때 A클래스만 사용하는 경우, 아니면 다른 경우에도 사용하는 경우에 따라 표기 달라짐
  - Association: 의미적 링크
    - Aggregation: 전체와 부분을 표현
    - Composition: 같이 죽고 같이 산다, 생성자 때 같이 생성
  - Generalization: 상속
  - Dependency
  - Implementation
- Sequence Diagram
  - 세로는 시간, 세로 네모는 인스턴스 생명주기, 화살표 위 문구는 메소드
  - 라우팅, 비동기 표시, 메소드(행위)
- State Chart Diagram
  - 상태 전이, 객체의 상태변화를 표현, 이벤트 발생에 따른 변화
- Deployment Diagram
  - 시스템 물리적 구성, 제품의 이름까지 작성되어 있음
- Component Diagram
  - 소프트웨어 물리적 단위 모델링 (exe, dll 등), 프로그램

## Java Code 변환

- 클래스를 자바 코드로 자동 생성
  - Association: 전역변수
  - Dependency: 메소드 내 지역변수, 메소드 파라미터
  - Realication: implements
  - Generalization: extends
- MDA(Model Driven Architecture)
  - 메타 모델을 사용한 설계 모델의 재사용 기법
  - 메타 모델을 기반으로 구현환경에 독립적인 시스템을 개발하고 자동으로 구현 환경에 배치하는 방법으로 소프트웨어 개발
    - 메타데이터: 자원을 설명하는 데이터, Resource를 설명하는 데이터
    - 메타모델: 설명하는 데이터를 어떻게 집어넣느냐, 구조에 대한 건
  - 목적: 설계의 재사용
  - 참고: UML Profile: OCL (Object Constraint Language)
  - MOF(Meta Object Facility): 모델에 대한 표준 저장소
  - CWM(Common Warehouse Meta Model): 데이터 저장소에 대한 모델 데이터베이스 스키마 변환
  - XMI(XML Metadata Interface): XML변환, XML이 표준이니까 변환가능
  - UML Meta Model
  - UML Profile: 스테레오 타입 태그, 태그 값 정의, MOF 메타 모델
- MDD 개발 프로세스
  - CIM(Computation Independent Mode): 비즈니스 요구항을 추출
  - PIM(Platform Independent Model)
  - PSM(Platform Specification Model)
- Product Line
  - 도메인 공통 컴포넌트를 사용해서 소프트웨어를 개발하는 프로세스
- Product Line Process
  - Core Asset Development (Collabration)
  - Application Engineering
  - Management
    - 형상관리, 변경관리, 버전 컨트롤 시스템, 변경 최적화하고 관리하는 프로세스, 변경을 추적하는 프로세스, CCB(Change control board)
    - VCS: SVN(중앙집중형), GIT(분산형 워크플로우, 스토리지 2개)
    - IEEE 4Step: 식별, 통제, 감사, 기록
      - Configuration Identification (식별)
      - Configuration Control, CCB (통제)
      - Configuration Status Accounting (상태관리)
      - Configuration Audit (감사, 산출물 감사, Baseline Core Asset)
  - 모든 프로젝트에는 Management Set 이라는 것이 있음
    - Requirement Artifact (유스케이스 모델링, 명세서)
    - 클래스 다이어그램 등
    - 소스코드
    - 테스트 시나리오, 테스트 케이스
- Domain Engineering
  - 특정 도메인 내의 애플리케이션에서 공통 컴포넌트(Core Asset)을 생산하기 위한 프로세스
  - 도메인 분석/설계/구현
- Refactoring: 소프트웨어 기능은 변경하지 않고 로직을 개선하는 활동
  - 외부 기능은 변경하지 않고 내부 기능을 개선
  - 언제 하는게 좋은가? > 개선시점 설명하는 것 핵심
    - 버그가 발견될 때
    - 소프트웨어 가독성 (Read Ability) 향상 목적
    - 모듈화 통한 재사용하고자 할 때
    - Performance(성능) 개선 목적
    - TDD, 테스트를 반복적으로 수행할 때
  - 리팩토링 기법
    - 클래스 추출 등

## 중간 정리

- 소프트웨어 리엔지니어링: 소프트웨어 품질 문제 해결
- 소프트웨어 위기: 비용지연, 생산성 저하, 품질 저하를 체계적인 방법으로 해결
- 소프트웨어 프로세스 모델: 소프트웨어 개발 과정에 대한 일련의 절차, 표준
- Incremental 개발 모델: 버전을 추가하듯이 개발, 테스트를 지속한다.
- 공정이 우수하면 제품도 우수하다고 가정
- CMMI: 미국 카네디대 개발 소프트웨어 품질에 대한 성숙도 모델
- 요구사항: 기능적, 비기능적
  - 비기능적 (품질요구사항, 명시적, 암시적), 접근성 (장애인, 일반인 균등하게)
  - 명시적: 산출물 정의
  - 암시적: 제안, 문서화되어 있지 않음 
- 유스케이스 모델: 사용자와 상호작용 모델링
- 유스케이스 명세서 (유스케이스 아이디)
- 정적 모델링 클래스 (애트리뷰트 + 메소드)
  - 연관, 상속, 의존, 구현
- 시퀀스 모델 (시간에 따라)
- 리스코프의 교체 원칙 (부모클래스를 자식클래스로 대체해야한다.)
- 입출력을 인터페이스로 분리
- 오픈 앤 클로즈: 전략 패턴

## 요구공학

- 프레임워크 (~를 하기 위한 방법)
  - 요구사항 개발
  - 요구사항 관리 (변경관리-변경추적 및 제어, 형상관리-베이스라인 통제)
  - 요구사항 툴(도구들) (모델링 도구, 엑셀, 워드 등)
- 요구사항 Verification / Validation 방법
  - 리뷰(개발자간 자유롭게), 워크스루(체크리스트), 인스펙션(체크리스트, 공식적, 중재자 통한 점검)
  - 프로토타입 통한 확인
  - 스프린트(개발범위) 리뷰
    - 플래닝 게임(Planning Game):
      - 다음 스프린트의 반복과정을 오늘까지 협의
      - 고객과 협의해서 다음 반복을 무엇을 할지 협상하는 과정

## Inspection 종류

- 요구사항 인스펙션
  - 완전성, 명확성, 일관성(이해관계자 간 충돌, 상충된 요구사항 없는가), 추적성
- 설계 인스펙션
- 코드 인스펙션
  - 코딩 표준, 에러처리, 논리적 오류 점검

## 코드 리뷰

- 코딩 준수
- 에러 처리
- 논리적 오류

## 제안요청서

- 활용분야
  - 발주, 검수기준, 
  - 제안PM, 제안전략 수립, 
  - 감리, 과입 이행여부 확인

## 프로토타이핑 제안전략

- 피엠 입장에서는 Man Month(MM)이 많이 든다.
- 사례가 없을 때 프로토타이핑 제안 가능

## 빅뱅과 나선형 모델

- 핵심: 리스크
- 리스트 완화 방법: 작은 단위 반복, PoC 진행

## 전자서명

- 5개의 키

## 비트코인 전자서명

- 내용 없음

## DrDoS

- SYN 패킷 탐지

## APT

- 지속적으로 죽을때까지
- 기본적으로 절차, 단계 4개 존재
- 공격기법
  - 스피어 피싱, 힙 스프레이
- APT 공격의 사례, 샌드박스 테스트

## 요구사항의 종류

- 정적
- 동적
- 기능적
- 품질 요구사항
- 기능, 비기능, 관리
  - 기능: 공통, 인터페이스
  - 비기능: 보안, 성능
  - 관리
- 요구사항 변경

## 망분리

- 기관 시설 사업자: 물리적 망분리 필요
- 망 연계 방법 (내부, 외부)
- 망 분리 시 메일 서버, 외부에서 내부 접근은 안된다
- 프린터: 스풀링이라는 것을 사용

## 테스트 (Test, Quality Control)

- 정의: 사전에 결함과 오류를 발견
- 기본적으로 품질 계획 수립
- SQPM (Software Quality Process Management) - 프로세스에 초점
  - 암시적
  - 명시적
- SQA 프로세스 (Software Quality Assurance Process) - 공정을 모니터링하는, 그 산출물을 관리하는 프로세스
  - 정의 (Quality Definition): 품질속성
  - 관리 (Quality Management): 계획, 품질 계획, 품질 보증 프로세스를 정의, 관리
  - 평가 (Quality Assessment): Verfication & Validation, Inspection, 인수테스트(사용자)
- 추가 설명:
  - Verfication
    - 공정에서 만든 산출물이 적합한지를 확인
  - Validation
    - 요구사항에 적합한 프로덕트/제품를 만들었는지를 확인
  - 요구사항 > 분석 > 설계 > 구현 > 유닛테스트(단위테스트) > 통합테스트 > 시스템 테스트 > 인수 테스트
    - Verification(프로세스 확인), Validation (테스트를 통해 제품을 확인)
    - Quality Assurance, Quality Control
    - 품질 보증, 품질 통제
    - 요구사항, 인수테스트
      - 기능적 / 비기능적, 고객이 사용, 알파테스트, beta테스트
    - 분석, 시스템 테스트
      - 요구사항 명세서 / 목표 성능 달성 여부 확인, 강도 최악의 시나리오 확인
      - 에이징, 보안(암호화, 접근권한, 권한 관리(Acceess Control)), Failover(가용성)
    - 설계, 통합 테스트
      - 클래스 모델링, 컴포넌트 / 모듈 간의 인터페이스 테스트(I/F 테스트), BDD, 드라이버(테스트 프로그램), Stub 필요 (Drive & Stub)
      - 모듈 > 모듈(Driver) > Stub
      - 테스트 자동화 프로그램 == 테스트 드라이버
    - 구현, 단위 테스트
      - 개발 / 가장 단위의 모듈을 확인(기능 확인), TDD, 화이트 박스 테스트 기법(안의 로직을 보면서 테스트), 통합테스트의 결함률을 낮추는 효과
  - Review(peer) 품질보증활동, 동료검토활동, Verification의 기법
    - Review: 자유롭게 검토하는 기법
    - Walkthrough: 리뷰보다는 공식화 정도가 높으나 공식화가 낮고(Inspection보다) 체크리스트를 사용한 검토
    - Inspection: 가장 공식적인 활동, 공식화 정보 높음, 체크리스트 사용, 중간에 목적 변경없음, 중재자 통해 진행
- 소프트웨어 테스트 설계 기법
  - 명세기반(블랙박스) 테스트
    - 형식적, 및 비형식적인 문제로 테스트 케이스를 유도
    - 동등분할, 결계 값, 의사결정(도메인(규칙)), 상태전이(조건, 행위에 대한 테스트) 등
  - 구조기반(화이트박스) 테스트
    - 코드와 디자인으로부터 테스트케이스 유도
    - 커버리지
    - 단위/통합/시스템 레벨
  - 경험기반 테스트
    - 경험 활용
  - 그레이박스
    - 블랙과 화이트 박스 혼합
  - 몽키 테스트
    - 랜덤 값으로 테스트
- 소프트웨어 테스트 절차
  - 테스트 계획 수립 - 성공의 기준, 80%이상이면 통과로 판단하겠다 등
  - 테스트 케이스 설계 - 시나리오, 입출금 ATM 기기를 예로 들어서 이해
  - 테스트 실행 및 측정
  - 결과분석 및 보고
  - 오류추적 및 수정

## Agile Process

- 애자일 프로세스와 방법론 구분 중요
  - 프로세스: 몇가지 원칙을 준수하는 것
  - 방법론: 스크럼, XP
- 애자일 프로세스 전제
  - 선언문 (Manifest)
    - 개인과 상호작용
    - 작동하는 소프트웨어
    - 고객과 협력
    - 변화에 대응 가능
  - 애자일 프로세스
    - 가변적인 요구사항에 대응하기 위해서 사람 중심의 프로세스
    - 구성요소: 선언문, 원칙, 프로세스, 방법론으로 구성
  - 방법론
    - 스크럼: 팀단위활동, Roles, 팀 단위 (2~4주 단위로) - 팀이 개발하니까, 리스크가 완화되는 효과, 스크럼의 목적은 팀관리, 팀단위 활동 강조
      - 팀단위 활동 중심의 애자일 프로세스
      - 제품 중심의 애자일 프로세스
      - (1) Product Backlog (요구사항, 유저스토리에서 추출, 비전과 요구사항 수집, 우선순위)
      - Product Owner (Key Stack Holder, 비전과 요구사항을 제시하는 사람)
      - (3) Sprint (2~4주 단위 반복 개발, 스프린트 개발)
      - (2) Sprint Backlog (요구사항 분할, 스프린트 선정)
      - (4) 스크럼 Review Meeting (개발팀 공유, 고객 참여, 확인, Planning Game)
      - Scrum Master (PO와 Scrum 멤버 중재자의 역할, 위험 관리 및 공유)
      - Daily Scrum (Daily Startup Meeting, 매일 서서 미팅, 불필요 시간 줄인다, 간략, 빠르게, 10~15분 정도, 어제한일, 오늘 할일, 리스크 공유)
    - XP (eXtreme Programming)
      - 커뮤니케이션, 단순성, 피드백, 용기를 기반으로 소프트웨어를 개발한 방법
      - 빠른 가치를 제공하겠다, 동작 소프트웨어를 빠르게 고객에게 주겠다, 빠른가치 > 분할
      - 빠른 피드백을 중요시
      - 공공 프로젝트 애자일 하면 안되는 이유
        - 고객이 팀원이 아니고 밖에 있으므로
        - 애자일을 쓸 경우 피엠의 역할이 중요 > 고객과 지속적인 소통해야 함
      - 4가지 특징 (5가지 특징)
        - 의사소통
        - 단순성(Simplicity)
        - 빠른 피드백
        - 용기 (Courage, 변화에 대응하는 자세)
        - (상호존중)
      - 12 Practice
        - On-Site Customer (고객참여)
        - Simple Design
        - Refactoring (개선, 가독성, 퍼포먼스, 개발 표준 준수, 다같이 개발하니까)
        - Pair Programming
          - (2인이 1개를 개발, 생산성 우수, 대화하면서 개발해라, 2인이 1개 개발하면 맨먼스 2개 들어감)
          - 초기에 페어프로그래밍 대상 업무를 선정해야 함, 비용을 무시할 수 없음
        - Collective Code Ownership
        - The Planning Game
        - Testing (TDD)
          - 테스트를 먼저해라
        - Continuous Integration
        - Small Releases
        - 40 hour week
        - Coding Standards
        - Metaphor~
    - TDD (Test Driven Development)
      - TDD 프로세스. 코드, 테스트, 리팩토링을 반복하는 프로세스/방법론
      - 중요포인트: 코드를 작성하기 전에 테스트 먼저 작성한다.
        - 설계 (구현가능한 모델)
          - 클래스 설계가 없으면 테스트 먼저 작성 불가
        - 테스트 (JUnit 생성)
          - JUnit 라이브러리추가, 단위테스트, (espresso (BDD, 행위테스트, 버튼 눌러서 UI 테스트))
          - class Test { TC001_SUM { class opreration myop; int ouput = myop.sum(10); AssertEquals(15, output); } }
          - TC002_SUM { ... AssertEquals(12, output); } <-- 의도적인 Fail 테스트
        - 코드 (개발 시작, 모델링 기반 개발)

## Agile 선언문(Manifest)

- 선언문 밑에 애자일 원칙이 있음
- 원칙
  - 빠른 피드백
  - 빠른 가치를 제공
  - 경량화된 프레임워크(F/W), 불필요 활동, 도구를 최소화
  - 가변적인 요구사항에 대응
- 이런 것들을 지키려다 보니 작은 단위로 개발
- 애자일 프로세스
  - 반복적 모델 사용, Incremental, Iterator, 1주(짧으면 짧을수록 리스크는 낮아진다)
- 애자일 리스크 관리 (애자일 위험 관리)
  - 최소단위 소프트웨어
  - 의사소통 (고객과 의사소통)
  - 개념증명 (PoC)
- 애자일 기본 구조
  - 선언문
  - 애자일 원칙
  - 애자일 프로세스
  - 애자일 위험 관리

## 소프트웨어 품질 (Software Quality)

- 주관적 문제점, 측정어려움, 시간에 따라 변화하는 문제
- 소프트웨어 품질
  - 개발과정 전체에 적용되는 보호 활동
  - 제품에 설정된 기술적 요구사항과 일치성을 확인하는 체계적인 활동
    - 기술적 요구사항과 일치성 > SQPM
- 품질관점 (Quality View)
  - 사용자: 다양한 기능 및 성능
  - 개발자: 표준에 맞는 프로그램
  - 유지보수자: 오류가 적고, 문서화, 이해용이성
  - 발주자: 유지보수 비용 최소화
- 품질측정 대상
  - 프로젝트: 진행관리, 측정지표, 진척율, 투입공수, 예산준수 (단계별 예산 필요 - 비용초과의 리스크 축소 가능)
    - EV(Earned Value), 범위 일정 고려 비용
  - 프로세스: 프로세스 성과 및 분석 관련 측정지표, 준수율, 결함 제거율, 인스펙션 효율성
    - 품질 보증 프로세스에 의해 관리되고 있는가
  - 프로덕트: 제품 품질평가, 규모, 복잡도, 품질특성, 재사용율 등
- 프로젝트 추청
  - Size
    - LOC, FP(Function Point, 기능이 어느정도 된다.)
  - Effort
    - MM, MH
- 소프트웨어 품질측정 방법
  - 크기 중심 매트릭스
    - LOC, (PERT), 원가/비용, Man-Month
  - 기능 중심 매트릭스
    - FP, 복잡성, 기능성, 신뢰성, 유지보수성, 효율성
- 소프트웨어 품질측정 방법 2번째
  - 직접법: LOC, FP, McCabe(회전 복잡도, 사이클론 매트릭스, 폐구간), Halstead 과학적 매트릭스(연산자, 피연산자 수)
    - 폐구간(if, for 등), 폐구간 + 1
    - 연산자 (A=B+A), 연산자: +, = 총 2개, 피연산자: A 2번, B 1번, 프로그램의 부피 계산
    - McCabe & Halstead : 예측을 못하는 전제\
    - PERT 라는 기법과 혼용해서 사용 가능
  - 간접법: 기능성, 사용성, 신뢰성
    - 품질 측정 절차 (모든 평가 절차는 아래 절차대로 진행)
      - 측정 목표 설정 (목표)
      - 픅정지표 정의 (지표)
      - 데이터 수집
      - 분석절차 정의
      - 측정결과 수집
      - 측정 데이터 분석
      - 결좌저장 및 공유
- SPI (Software Process Improvement) 프로세스 개선활동
  - 프로세스 개선, 공정 개선
  - 프로덕트, ISO-9162, GS인증
    - 프로세스, 프로덕트 > 프로세스 관리
    - ISO 12207
    - SPICE ISO-15504
    - CMMI (개발 조직의 성숙도 모델)
- Cost 추정 기법
  - 전문가 감정 (계획에 의한 추정법, 관리자에 의한 추정법)
  - 유사 추정 (과거 유사한 프로젝트와) (계획에 의한 추정법, 관리자에 의한 추정법)
  - 파라메터 (수학)
    - LoC, FP
  - 상향식 (Bottom-Up, WBS 법): 상세 추정법, 담당자에 의한 추정, 정확도 높으나 느림, WBS가 끝나야 알수있으니까
    - WBS --> Work Package 단위 (2주안에 완료할 수 있는 일) --> 전체로 확산
    - 정확도 높음, 요구사항이 명확하게 확정
    - 예측 단계에서 사용하기 어려움, 현실적 어려움
  - 3점 추정
    - PERT, CPM(1점 추정)
  - 입찰가(Bid, Vendor Bid)
- 품질모델 (Quality Model)
  - McCall의 Quality Model
    - 프로덕트 전환
    - 프로덕트 운영
    - 프로덕트 수정
  - Boehm의 Quality Model
    - 이식성
    - 사용성
    - 유지보수성
  - ISO 9126 품질특성
    - 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
  - FURPS+ (Compliance)
- ISO 품질관련 표준 모델
  - 제품관련 모델
    - ISO 9126
    - ISO 14598
    - ISO 12119
    - ISO 25000
    - GS(Good Software)
      - 우선 구매제도(분리발주), 국내 제품 소프트웨어 품질 특성, 성능평가
  - 프로세스 관련모델
    - ISO 12119
    - ISO 15504(SPICE): 2차원 구조의 능력인증 모델
    - Cmmi: 카네기멜론 대학교 SEI ~ 품질 성숙도 모델
      - SW-CMM, P-CMM, IPD-CMM등을 통합한 단일화된 모델
      - *PA: 변경/배포관리, 요구사항 개발/관리
      - 단계형
        - 초기>반복>정의>관리>최적
          - 초기(표준 X)
          - 반복(경험, 표준) -> 요구사항 개발
          - 정의(전사 표준) -> 변경관리, 배포관리, 모든 업무에 다 반복 적용
          - 관리(정량적 측정)
          - 최적(지속적 개선)
      - 연속형
    - SP(Software Process) 인증
      - 국내 중소기업을 위한 소프트웨어 프로세스 품질인증 모델(한국, 국내 사용 모델)

## Software 규모 산정 (정량적인 측정)

- LOC (Line of Code)
  - WBS 상에 분해된 시스템의 원시코드 라인 수를 산정
  - LOC 산정(예측) 방법
    - 작업 예측치: 최적치 + (4*근접치) + 최악치/6
- COCOMO(Constructive Cost Model)
  - LOC에 나타난 프로그램 크기 함수로 정적 단일변수 모델
- COCOMO 프로젝트 개발 유형
- COCOMO II
- 생명주기 예측모델
- 기능점수 (Function Point)
  - 사용자가 요구한 기능, 사용자 관점에서 기능을 정량적으로 측정하는 소프트웨어 규모 산정기법 (ISO-14143)
  - 애플리케이션의 범위와 경계 식별
    - 홈쇼핑: 회원가입, 주문, 배송, 결제, 이것들이 애플리케이션 범위, 결제는 PG사, 배송은 택배사, 회원가입과 주문은 고객과 연계
    - 주문: 
      - 회원 확인, 회원주문, 비회원주문, 상품(도서, 티켓, 항공 등)
      - WBS, 발주(현금, 카드, 포인트), 상품(상품코드, 상품명, 금액, 재고수량, 등록자, 아이디) <-- 이런 분류들은 RFP에 나와있어야 함
      - 상품 데이터베이스(ILF), EI(External Input, 입력), 조회(EQ), EO
        - 범위 경계 안으로 입력이 들어오는 것 EI
      - Transaction, BigData
      - INF: 상품, DET: 5, RET : 2 => 낮음 => 7점, 복잡도 매트릭스 => 기여도 매트릭스, EIF => 5, 총 12점 (데이터 기능점수)
      - FTR, DET, INF, ILF, EI, EQ
- 기능점수 산정종류
  - 간이법: 표준 데이터, 제안단계 산정
  - 정규법: 정확한 소프트웨어 규모 측정, 완료 시점
- 기능점수 측정요소
  - 데이터 기능점수
    - ILF(경계 내에 유지되는 데이터 그룹), EIF(경계 밖에서 참조되는 데이터)
  - 트랜잭션 기능점수
    - EI(경계외부에서 유입되는 데이터), EQ(경계 밖으로 보내는 데이터), EO(경계밖으로 보내고 가공하는 데이터)
- 기능점수 산정절차
- 기능점수 측정유형
  - 개발
  - 개선
  - 애플리케이션: 현재 시점의 기능(Baseline)

## 정보시스템 감리

- 감리
  - 독립적인 조직이 평가하는 것
  - 감리 발주자 및 피감리인이 이해관계로부터 독립된 자가 정보시스템의 효율성을 향상시키고 안정성을 확보하기 위하여 제3자적
  - 관점에서 정보시스템의 구축에 대한 사항을 종합적으로 점검하고 문제점을 개선하기 위한 활동
  - 발주기관, 사업자에게서 독립될 수 없다. 감리가 왜 독립될 수 없는지, 독립하면 안되는지?에 대한 생각 필요
- 현실적인 면
  - 지식의 힘 차이, 대기업 SI나 특정 업체를 유지보수를 한 사업체한테 의존할 수 밖에 없는 구조 (금융, 법 쪽 등)
  - 빅데이터, IoT, GIS DB 등 감리 어려움 > 전문성 필요 > 감리 참여인원의 30%은 전문가 투입 가능 정책 변경 (모순)
    - 전문가 누구를 데리고 와야 하는가? > 교수 급 > 일반적인, 큰 단어로 설명하는 문제/현실
    - 인건비 저렴한 전문가 투입하는 현실
- 감리시점에 따른 유형
  - 상시감리
  - 상주감리
  - 의무감리:
    - 공공 정보시스템 감리 의무화
    - SW 개발 사업비 5억이상 (순수 소프트웨어 개발지 5억 이상)
    - 비용과 관계없이 대국민 서비스, 사업비와 관계없이
- 감리절차
  - 감리 계약체결
  - 감리 계획수립
  - 감리 착수회의
    - 점검항목 공유(점검항목에 없는 것은 보지 않겠다), 검사기준 공유
    - 부실확인 관련
  - 현장감리 수행
    - 증적, 테스트
    - 문제점을 증빙할 수 있는 증적 확인이 핵심
    - 증적 확보 시 중요한 포인트는 테스트를 많이 하는 것
    - 기존 테스트케이스 외에 감리 자기 자신의 테스트케이스가 필요
    - 샘플링 중심 테스트의 위험
    - 정상적인 테스트에 대한 검증, 감리의 역할
  - 감리 종료회의
  - 감리 조치확인
- 공통 감리 (3단계 감리)
  - 요구사항 단계 감리 (20억 이상 사업에 대해서 요구사항 단계를 추가시킨 것, 원래는 설계, 종료 단계 2개만 존재)
  - 설계단계 감리 (구현할 수 있는 모델이냐, 요구사항 분석 설계, 검사 기준서 준비)
  - 종료단계 감리 (적합, 부적합 판별, 점검제외, 조치확인)
- 정보시스템 감리영역(개발)
  - 사업관리 및 품질보증: 과업 이행 여부, 단계별 투입인력적정한가, 진척률 산정 정확도
  - 응용 시스템
    - 핵심은 테스트 많이 하는 것, 정상적인 것과 실패 건을 같이 공유 필요
  - 데이터베이스: 구축이 완료된 것에 대해서는 모델링 감리가 아닌 성능 감리가 필요
    - 잘못되었다 하더라도 모델링 변경은 어렵다.
  - 시스템 구조 및 보안: 웹취약점, 개인정보
- 감리 프레임워크
  - 정보시스템 감리의 객관화, 체계화, 부실감리 방지를 위한 표준화된 감리체계

## 인수 테스트(Acceptance Test)

- 인수 테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트

## 응용 프로그램 종류

- Batch Processing System: 대용량 데이터를 처리하는 프로그램
- Entertainment System: 유져가 즐길 수 있는 프로그램 (게임 등)
- System for Modeling and Simulation: 시뮬레이션이나 모델링을 위한 시스템
- Data Collection System: 다른 시스템에서 전달 받은 데이터들을 수집하는 시스템
- System of System: 다양한 시스템끼리 구성되어 상호작용

## 좋은 소프트웨어가 가져야 할 특성

- 유지가능성 (Maintainability)
- 신뢰성과 보안 (Reliability and Security)
- 효율성 (Efficiency)
- 접근가능성 (Acceptability)

## 주요 개념 키워드 및 간략 설명

- 동료검토
- 유스케이스 모델링
- 클래스 모델링
- 소프트웨어 아키텍쳐 스타일
  - GRASP
- Verification & Validation
- 유틸리티 분석
  - SQA
  - SQQ
- 디자인 패턴
- 전략 패턴
  - 알고리즘 교체
  - 동적 알고리즘 추가 가능
- 템플릿 메소드
  - 추상화 메소드 개념
- Smurfing
  - 핑 전송 했는데 잘못된 Destination으로 가는 것
- 객체지향 설명 원칙 5개
- 유스케이스 드리븐
- 형상관리-베이스라인 통제, 변경관리-변경추적 및 제어, 버전 관리 시스템(VCS, GIT, SVN)
  - 형상관리: 베이스라인 등
- 소프트웨어 아키텍쳐 수립 목적, 고려사항, 구축방법
- BDD
- CMMi
- 정보시스템 감리의 문제점
- 애자일 위험관리 설명
- 스크럼 역할에서 비즈니스팀, 프로덕트 오너, 마스터, 개발팀 역할 각각 설명
- XP에서 고객에게 빠른 가치를 제공하는 방법
- 경량화 프레임워크
  - 프로세스 줄이고 산출물 기간 짧게, 변경 대응 가능
- SQA 설명, 프로세스 설명
- 공공 프로젝트에서 XP보다 스크럼을 개발 방법론으로 사용하는 이유
- TDD, JUnit 사용 예
  - 코드보다 테스트를 먼저 작성한다
  - 그러면 코드를 먼저 작성하는 예는 무엇인가?
- 애자일 선언문, 원칙, 프로세스, 방법론 설명
- 스크럼에서 팀단위 활동 설명
- SQPM 설명
- 요구사항의 종류와 문제점
- 정보보호관리체계 설명
- 망분리
- 소프트웨어 프로세스 모델과 개발방법론 차이점
- 매슬로우 욕구 4단계
  - 무인식, 무능력
  - 인식, 무능력
  - 인식, 능력
  - 무인식, 능력 (마스터)
- 인지편견 문제
  - 결정을 객관적이지 않고 주관적으로 수행
  - 특정 조직원에 의해 주관적으로 평가되는 문제
  - 인지편견 문제 있는지 없는지 확인
- 드렁크의 효과
  - 자신이 무능력한데 능력있다고 생각하는 것
  - 능력이 있는데 자신이 무능력하다고 생각, 수동적 태도 보임

## SDLC
- SDLC 장점
  - 의사소통, 재사용, 가이드라인
- RAD: 컴포넌트를 재사용
  - JRP: 고객과 함께
  - JAD

## 요구공학
- 요구사항 문제
  - 변경, 도메인, 의사소통
- 요구공학
  - 요구사항의 문제점을 체계적으로 해결한 방법
- 요구공학 원칙
  - 완전성, 명확성, 일관성, 추적성(과업대비표)
  - 추적성을 관리하는 프로세스: 변경관리 (변경을 추적하고 제어한다 > 버전 컨트롤 시스템 필요 > 형상관리 > 베이스라인 통제 > 식별, 통제, 감사, 기록)
- 요구공학 프레임워크
- 유스케이스 명세서
  - 유스케이스 별 상세화 작성
- 인스펙션
  - 체크리스트 기반 가장 공식적인 활동
- 유스케이스 다이어그램
  - 액터-유스케이스, 유스케이스-유스케이스 상호작용 표현
  - 유스케이스-유스케이스 간 관계: include, extend
- 유스케이스 다이어그램과 유스케이스 Specification을 Validation 하는 방법
  - 프로토타입, 인스펙션
- Formal Review
  - Review, Walkthrough, Inspection
- 코드 익스펜션, 코드 리뷰(논리적 구조, 개발 구조, 에러 핸들링)

## 소프트웨어 아키텍쳐
- 소프트웨어 아키텍쳐: 핵심 구성요소 / 구성요소간의 상호작용 정의한 청사진
- 요구사항 종류
  - 비기능: 유틸리티 분석 통해 중요도, 난이도 사용하여 우선순위 결정
  - 기능
- 아키텍쳐 스타일
  - 레이어, 파이프 앤 필터, 쉐어드 디스크, 클라이언트-서버
  - 장점: 의사소통, 재사용, 가이드라인
- 아키텍쳐 평가 방법
- 아키텍쳐 구축 기대 효과
  - 의사소통, 재사용, 가이드라인
- 컴포넌트 앤 커넥터 (인터페이스)
- Allocation View (하드웨어 위에 올라간 컴포넌트 모습)
- Code View(패키지)

## 객체지향 분석/설계 재정리

- 객체지향 특성
  - 추상화, 캡슐화, 상속, 다형성
- 추상화
  - 복잡한 것을 간단하게, 공통적인 요소, 간단하고 공통적인 요소
  - 종류: 기능, 자료, 제어
- 캡슐화
  - 애트리뷰트와 메소드가 결합된 클래스로 모델링하는 것, 클래스
  - 위 클래스를 가지고 오브젝트로 개발하는 방법 > OOP
  - 접근 지정자: public, private, protected
- 상속
  - 부모의 특성을 자식이 물려받는 것
- 다형성
  - 런타임 시 동일한 메세지에 대해서 객체가, 클래스가 반응하는 특성
  - 다형성 종류: 오버라이드, 오버로딩
- 객체지향 특성 (추가 버전)
  - 추상화, 캡슐화, 상속, 다형성, 정보은닉
- 정보은닉: 중요 정보의 직접 접근은 제한하라.
  - public 메소드로 private 변수를 참조하라
  - information hiding

- 객체지향 방법론
  - 애트리뷰트와 메소드가 결합된 오브젝트로 개발하는 방법

- RUP 4+1 View
  - 유스케이스 View
  - 로직(Logical) View
  - 프로세스 View
  - Implementation View
    - 앱 구성, 컴포넌트 그룹화
  - Deployment View
    - 서버 구성도, 컴포넌트가 노드에 배치

- 객체지향 설계원칙 (SOLID)
  - 1.인터페이스 분리(ISP)
    - 필요 없는 메서드는 인터페이스에서 제외해야 한다는 원칙
    - Print와 Scan 이 두 기능을 한 인터페이스로 묶으면, Print만 가능한 프린터기는 불필요한 "Scan"도 구현해야 합니다
  - 2.개방과 폐쇄(OCP, Open,Close), 대표적인 디자인패턴-전략패턴 (알고리즘 확장, 선택)
    - 확장에는 열려있고 변경에는 닫혀있음
    - 기능 확장에 열려 있고, 수정에는 닫혀 있어야 한다는 원칙
    - Association, Realization으로 모델링한다.
  - 3.단일책임 원칙(SRP)
    - 한 클래스는 하나의 책임(기능)만 가져야 한다는 원칙
    - 만약 User 클래스가 사용자 정보를 관리하고, 사용자 정보를 출력하는 기능까지 포함하고 있다면 이 클래스는 두 가지 책임
  - 4.리스코프 치환원칙(LSP)
    - 하위 클래스는 부모 클래스를 대체할 수 있어야 한다는 원칙
    - 상위 클래스의 메소드를 하위 클래스로 대체가능해야 한다. 다형성
    - "탈것"이라는 부모 클래스가 있을 때, 자식 "차량"과 "비행기"가 있다면 차량은 fly() 메서드를 사용할 수 없음
  - 5.의존관계 역전(DIP)
    - 고수준 모듈은 저수준 모듈에 의존하지 않도록 해야 한다
    - 추상화된 인터페이스에 의존하도록 합니다
    - OCP의 인터페이스 버전

- SOLID 즉, 객체지향 설계원칙 지켜야 하는 이유
  - 확장성과 유지보수성 향상
    - 새로운 기능을 추가하거나 기존 코드를 수정할 때, 다른곳에 미치는 영향을 최소화
    - 결합이 낮아진 만큼, 새로운 요구사항에 대응하기 쉬워진다
  - 코드 가독성 향상
    - 원칙에 맞는 코드는 더 명확하고 일관성 있는 구조를 갖추게 되므로, 다른 개발자들이 코드를 이해하고 수정하는 데 큰 도움이 됩니다.
    - 마치 우리가 표준화된 도구를 사용할 때처럼 협업에 유용
  - 확장성 개선

## UML Diagram

  - 모델링
    - 정적 모델링: 클래스 다이어그램
    - 동적 모델링: 시퀀스 다이어그램
  - 사용자 입장 모델링: 유스케이스 (UDM)
  - UML 다이어그램
    - 유스케이스, 클래스, 시퀀스, 컴포넌트, 디플로이먼트 다이어그램
  - 클래스간 관계
    - Association: 의미적 링크 관계, 호출
      - 코드: 전역변수
    - Realization: 클래스, 인터페이스 간 실행 관계
      - 코드: implements
    - Inheritence(Generalization): 부모 자식 관계
      - 코드: extends
    - Dependency
      - 코드: Method내 지역변수
  - 모델링 목적: 가시화, 명세화해서 의사소통 목적
    - 가시화 수준: 개념, 논리, 물리
  - 설계 레벨 재사용 아키텍쳐: MDA (Model Driven Architecture)
    - MOF: 모델링 저장소, UML Profile을 사용하여 저장
    - CWM: 데이터베이스 모델로 변환
    - XMI: XML으로 변환
    - UML: 가시화 언어
  - MDA 장점
    - 가이드라인, 의사소통, 재사용(설계에 대한 재사용)
  - MDD 개발 프로세스 (Model Driven Development)
    - CIM
    - PIM (설계 독립 모델)
    - PSM (설게 종속 모델)

## Coding, 자바 코드 변환: 실제 구현할 수 있는 모델

- Product Line
  - Core Asset을 사용해서 소프트웨어를 개발하는 방법, 소프트웨어를 재사용하는 방법
  - 도메인 공통 컴포넌트를 사용해서 소프트웨어를 개발하는 프로세스
  - 종류
    - 도메인 엔지니어링: 분류, 정의, 식별 작업
    - 애플리케이션 엔지니어링: 조립을 통해 소프트웨어 개발
  - 장점
    - 의사소통, 재사용, 가이드라인
- Refactoring
  - 외부 기능 변경 없이 내부를 개선하는 활동
  - 기법: Restructure
    - Extract Method (함수 추출)
    - Extract Class (클래스 추출)
    - Move Method (함수 이동)
    - Rename Class or Method (함수, 메소드 이름 변경, 수정)
  - 반복적으로 수행
  - 리팩토링 후 해야할 일
    - 코드리뷰, 코드 표준 준수했는가?, 표준검수, 에러핸들링, 로직 오류
  - 장점: 재사용 (구조화 덕분), 코드 표준 준수, 품질 강화, 효율성 증가

## 소프트웨어 테스트

  - 정의: 사전에 결함을 제거하기 위한 활동
  - 종류
    - Verification
    - Validation
  - 단걔
    - 단위테스트
    - 통합테스트
    - 시스템 테스트
    - 인수테스트