# Software Engineering

정리될 내용들은 아래와 같습니다.

- 개념 / 용어 정의, 사용 이유
- Interview Question, Answer

## 소프트웨어 공학 범위

전체범위 4가지중 소프트웨어 공학
- 소프트웨어 공학
  1. 방법론: OOP, UML(UseCase, Class, Sequence, Component, Deployment)
  2. 프로젝트 관리: RFP 범위, WBS(구조), 일정 (일의 순서, PND), 비용
  3. 품질
- 데이터베이스
- 정보보안
- IT 경영

## 소프트웨어 공학 정의 / 문제 사례

- 소프트웨어 위기 극복을 위한 대안
- 대표적인 위기/문제 사례
  - 비용 증가 (예측, Budget이 정확한가)
  - 생산성 (규모와 노력, 노력의 정도)
  - 일정 지연 (진행 과정, 개념 증명, 변경, 표준화된 툴(간트차트 등))
  - 품질 저하 (주관, 변화, 측정) : 주관적이고 시간에 따라 변화
- 복잡한 시스템
  - 규모
  - 인터페이스
  - 알고리즘 (기능 동일한데 복잡한 알고리즘, 효율적이지 않은데 복잡한 코드, 알고리즘 문제)
- 재사용의 크기
  - 너무 크면 인터페이스는 줄어듬
  - 재사용율은 떨어짐
  - 독립적인 단위/부품 => 컴포넌트

## 프로세스 모델

- 소프트웨어 방법론에 대한 추상화된 형태
  - 계획, 발주/계약, 사업착수, 계획, 실행
  - 요구사항, 분석, 설계, 구현, 테스트
- 모델 종류
  - 폭포수: 순차적
  - 프로토타이핑: 요구사항 확인
  - 반복형: 요구사항 ~ 테스트 반복
  - 점진형: 버전 추가하듯이 개발 (새로운 기능 추가하듯이 개발)
  - 나선형: 반복적 위험 분석/평가
  - 빅뱅: 작은 위험 (이전 프로젝트의 산출물을 어느정도 재사용 가능한 상황 등)
  - 애자일: 경량화, 작은 단위 개발

## 방법론

- 개발을 위한 구체적인 모든 것을 포함하고 있는 방법
  - 절차, 산출물, 도구 등
- 방법론 종류
  - 구조적: 기능(모듈) 단위
  - 정보공학: 데이터 중심, Integration (통합) -> 표준화 -> 데이터 표준화, 데이터를 표준화해서 통합한다는 개념
  - 객체: 데이터 + 메소드 (오퍼레이션) 결합
  - 컴포넌트: 독립적인 실행 단위
  - Product Line: 업무 공통 컴포넌트, Core Asset
  - SoD (SoA): 업무 로직
  - 6 Sigma 개발 (DMAIC): 정량적 품질 관리, 고객중심의 정량적 품질 관리
  - TDD: 코드 전 테스트 설계, 테스트 가능한 프로그램 제작, Unit 테스트에 포커스
  - BDD: 행위 주도 개발 (Behavior Driven Development)
    - TDD 근간으로 파생된 개발 방법
    - 테스트 케이스 자체가 요구사양이 되도록 하는 개발 방법
  - BDD 기본 패턴
    - 시나리오 기반으로 테스트 케이스 작성, 일반 사람이 봐도 이해할 수 있는 정도의 레벨 권장
    - Feature: 테스트에 대상의 기능/책임 명시
    - Scenario: 테스트 목적에 대한 상황 설명
    - Given: 시나리오 진행에 필요한 값 설정
    - When: 시나리오 진행에 필요한 조건 명시
    - Then: 시나리오 완료 시 보장해야 하는 결과 명시
  - Scrum: 팀 활동, 팀은 어떻게 조직화 시키고 각자의 업무는 무엇인가에 포커스
  - XP: 빠른 피드백, 빠르게 가치 제공
  - Kanban: 작업량 제한
  - Lean: 낭비 제거

## Process Management

- 소프트웨어 작업의 흐름 체계화
  - Input, Tools, Output
- Product가 아닌 Process에 포커스

  | ISO9000 | Cmmi    |
  | ------- | ------- |
  | 제품 규격, 프로세스 | 소프트웨어 개발에 대한 프로세스|

- QA, QC

## SDLC (개발 생명주기)

- Software Development Life Cycle
- 소프트웨어 탄생부터 소멸까지의 과정
  - 계획, 발주, 제안, 계약, 사업관리, 개발, 검수, 유지보수 (하자, 유상보수)
- 모형화
- SDLC 과정
  - 타당성 검토
    - 소프트웨어 사업의 추진여부를 결정하기 위해 사전에 검토하는 것
    - 기대손실, RoI, NPV (Net Present Value), IRR (Internal Rate of Return), 기술력, 가용성, 현재 여유 인력
  - 요구사항 정의: 범위, 기능적, 비기능적 (품질 요구 사항, 암시적, 명시적)
    - 명시적 요구사항: 개발보안 (Secure Coding), 웹 취약점 검사, 웹 호환성, 웹 접근성 (일반인, 장애인 차별없는 서비스 제공), 개인정보, 성능
    - 암시적 요구사항: 핵심인력 활용한 개발, 변경 최소화, 사용자 맞춤형, 원래는 명시적 요구사항에 포함되었어야 하는 항목들인데 여러 상황으로 빠지거나 늦게 추가된 것들
  - 설계
  - 개발
  - 이행: 배포
- SDLC 모델 종류
  - 폭포수 모델
    - 순차적, 검증 Verification 후 다음 단계, Verfication 은 기능 관점
    - Validation 은 행위관점, 고객 관점, 요구사항 확인 어려움, 중간중간 확인 어려움
  - 프로토타이핑
    - 시제품 개발, 확인, 이해관계자들에게 확인, 실험적, 진화적, 수직형, 수평형 모델
    - MM 낭비, 제안전략, 개념증명, 단계별 투입 인력, Validation, BDD
  - 증분 모델
    - 버전 추가 방식, 버전 단위, 핵심 요구사항, 개발하며 통합, 반복, 
    - 요구사항/분석/설계를 반복, 반복 단계별 산출물이 무엇인지 정의 필요하며 정의가 되어야 반복 가능
    - BaseLine (고객에게 승인된 산출물)
  - 진화적 모델: 반복형 점진형 모델, PMO, 포트폴리오, 조직에 목적과 맞는 소프트웨어 관리
  - 나선형 모델: 아키텍쳐, 통합, 대규모 프로젝트 적합
  - RAD (Rapid Application Development): 위험 적고 Reuse Component 사용, 빠른 개발

## 요구사항 분석

- 과업의 범위 확인, RFI
- RFP
  - 목적, 사업의 범위, 추진 계획, 일정, 핵심 요구사항, 분류, 선택, 비기능적, 사업관리 요구사항
  - 프로젝트 요구사항, 보안, 보고시점 (마일스톤), 인력, 입찰, 조건/방법, 기능 점수, 제안 평가
- 제안서 
  - 사업 목적 / 이해, CSF, 통합, 
  - 제안전략 (외부 전문가 활용한 개녕, 프로토타입 통한 사전검증, 인력, 유사 사태), 
  - 실행방안, 기대효과, 기술부분, 사용관리, 제안업체 소개, 재무재표
- 기술협상
- 착수 PMBOK
- 공식 시작
- PM에게 권한 허가
- Planning
- 사업수행계획서(프로젝트 관리 계획서)
  - PM은 검수의 기준으로 바라보아야 한다.(과업 이행의 점검 기준)
  - 범위(WBS, 진척률), 과업대비표(진척률), 일정, 투입 인력, 단계별 산출물, 방법론, 검수기준
  - 진척률에 대한 검수와 확인 필요 (기준 필요)
  - Baseline, PM이 임의로 변경하면 안됨, 고객과 승인된 내용, 도장찍은 협의된 내용
  - Baseline 만들어지고 나면 변경 관리 필요
- 범위, 일정
- 비용
- 요구사항 수집 출처
  - RFP: 기능 및 비기능
  - 제안서: 기술부분, 지원부분, 추가제안(애매한 제안)
  - 기술협상: RFP와 제안서 상 명확하지 않은 요구사항 검토
  - 핵심 이해관계자: 핵심 질문(Key Question), 서브 질문, 질의서 작성 필요, 이해관계자만의 요구사항 확인(동적 요구사항)
- 요구사항 정의서 (엑셀 목록)
  - 구체적이지는 않으나 완전성 목적(빠진것 없어야 함), 우선순위 협의
  - ID, 명, 설명, 중요도, 난이도, 우선순위, 이해관계자, 현행 시스템 여부(신규/개선/이관), 수용여부
- 명세서 (유스케이스 리포트)
  - 요구사항 정의서 내 작성된 설명의 상세화, 세분화
- 요구공학
  - 식별, 분석, 명세, 검증: 요구사항 개발
  - 유지보수: 요구사항 관리 (변경 관리, Cmmi)
- 요구사항 원칙
  - 완전성: 시스템 구현에 필요한 모든 것 표현
  - 명확성:
    - 모든 엔티티와 애트리뷰트는 단 한가지로만 해석되어져야 함
    - 도메인 용어 정의, 업무 용어 정의, 나눠질 수 없는 단위로 해석이 되어야 함
  - 일관성: 요구사항들 간의 충돌 없어야 함 > 요구사항 그룹핑 필요 (PM 역할)
  - 추적성
    - 모든 사용자의 로그인부터의 행위는 기록되고 관리되어야 함, 상호 맵핑되고 관리 필요
    - 탑 다운의 의사결정 내용은 관리자, 실무자까지 추적되고 통제되야 함
- 요구공학 프로세스
  - 요구사항 및 시스템 범위: 연계대상, 미확정 리스트, 엔드 유저
  - 요구사항 정의: 선행조건, 후행조건, 액터 (유스케이스를 실행하는 사람/시스템, 이벤트를 발생시키는 주체)
    - 액터는 모델링의 대상이 아님, System Boundary 밖에 있음, 연관, 상속 등의 화살표로 표시
    - 스테레오 타입(사용자 정의 타입), include, extend
  - 요구사항 명세화: 유스케이스 아이디/이름
  - 테스트 시나리오(케이스)
- 요구사항 확인
  - Walkthrough, Inspection 등
    - 체크리스트 기반한 점검 (주석, 함수명, 파라미터 규칙 관련 체크리스트)
  - 사전에 오류/결함 제거
    - 동료 검토 기법
    - 품질 보증 기법
  - Review: 자유롭게 검토, 서로 의견 공유
  - 요구사항 관리 문제점
    - 업무에 대한 이해 부족, 업무 범위 변경, 일정 및 자원부족, 의사소통, 명세화 부족

## 공식적인 활동 측면에서 Inspection 과 Walkthrough

- Walkthrough
  - 주제, 체크리스트를 가지고 점검하는 도중에 심각한 이슈 발생 시 중단하고 주제 변경 가능
- Inspection
  - 어떤 주제를 끝내고 다른 주제의 Inspection으로 이어간다
- Review
  - 자율성 고려한 검토

## 요구사항 문제점

- (공공, 전자정부 사업, 금융권 시스템 등) 요구사항의 문제점
  - 도메인 용어 정의 필요 (현재가, 체결가, 시세는 같은 의미를 가지고 있으므로 공통용어, 용어에 대한 정의 선행 필요)
    - 업무가 복잡하거나 다국어 프로젝트 진행 시에 해당
    - 정의가 안되면 업무 이해가 어려움
  - 업무에 대한 이해: 현업 담당자도 자신의 담당 업무만 이해하고 있는 문제
  - 변경 여부: 변경에 대한 판단 기준 합의 (왜 발생하고 변경 발생이 받아들여질 수 있는지를 사전에 합의)
    - 변경 분류를 통한 영향도 분석 필수, 변경 유발 요인 분석(현업 조직 변경 / 업무 또는 제도 변경)
    - 업무 / 제도 변경: 신규 상품 파생, 개인정보보호법 등, 요구사항 수립 때 사전에 선을 긋는 것이 중요
    - 무결성/추적성: 누가 요청을 했고 언제 배포했고 등의 히스토리 정리 필요
  - 커뮤니케이션과 조직 문제
    - 사용자 - 개발자 간 직접적인 소통, 대규모 프로젝트에서는 적합하지 않음
    - 유지보수 사업 때 문제, 개발자, PMO간의 혼란, 관리자 통하지 않으므로 소통 혼란 야기
  - 인지편견/편향 문제 (인지 터널, 착각)
    - Cognitive bias: 경험에 의한 비논리적 추론으로 잘못된 판단을 하는 것 의미
  
## 방법론

- 원칙:
  - 추상화:
    - 책의 목차 생각, 간략하게 표현한다는 의미
    - 공통을 식별해서 중복을 방지, 데이터/Procedure(Function) 추상화가 있음  
  - 정보은닉: 중요 데이터에 대해 직접 참조 제한 (접근 지정자 - public, private, protected)
  - 모듈화
    - 독립된 단위로 구성
    - 평가 기준: 결합도, 응집도
    - 상속은 높은 결합도, 결합도가 낮다고 좋은 것이 아님
  - 상속
    - 부모의 특성을 자식이 물려받음
    - 트리의 너비와 깊이가 넓어지면 질수록 복잡성 증대하나 확장성/재사용성 좋음
  - 캡슐화
    - 애트리뷰트(데이터)와 메소드(오퍼레이션)가 결합된 클래스로 표현
    - 캡슐화는 접근 지정자를 제공해 줌
- 모델링:
  - 유스케이스 다이어그램(사용자 관점)
  - 클래스 다이어그램(논리적인 구조, 프로그램 내부)
  - 시퀀스 다이어그램(동적 흐름)
  - 컴포넌트 다이어그램
  - 디플로이먼트 다이어그램
- 아키텍쳐 스타일(패턴): 클라이언트-서버
- 패턴:
  - GRASP (낮은 결합도와 높은 응집도를 지켜야 함)
    - General Responsibility Assignment Software Patterns
  - 디자인 패턴 (설계 문제에 대한 해결책)

## 리팩토링

- 외부 기능은 변경하지 않고 내부 기능을 개선하는 것
  - 가독성 증대, 성능 개선 목적
- 반복적으로 지속적으로 행해져야 하는 활동, 일회성 X

## 소프트웨어 아키텍쳐 - 정보시스템의 구조(분류)를 확립

- 사전 설명
  - 구조, 분류, 공통, 의사소통
  - 공통을 먼저 식별하고 분류한다.
  - 분류는 컴포넌트, 인터페이스(I/F) 말이 항상 같이 따라옴
  - 대민시스템(민원처리, 특허정보 시스템 등), 분석시스템(빅데이터, DW)
  - 소프트웨어 아키텍처는 처음에 분류를 하는 것이 최우선
- 정보시스템의 핵심 구성요소 및 구성요소 간의 상호작용을 정의한 청사진/구조
  - 상호작용이란 회원가입>로그인, 로그인>주문가능 이런 것들
  - 상호작용: 비즈니스 업무간, 앱과 DB, 엔드유저와 정보시스템, 기술
- 아키텍처 기능
  - 프로젝트에 영향을 주는 이해당사자 간의 의사소통, 프로젝트의 키 스택 홀더(프로덕트 오너)
    - 이해당사자: 사용자, 스폰서(경제적인 부분), PM, 개발자
    - PM는 프로젝트의 키 스택 홀더가 많으면 많을수록 어려워짐
  - 설계 초기에 의사결정 기준
    - 설계>기능(완전)으로 아키텍쳐를 우선 확립 후
    - 비기능으로 성능 개선, 제안1,2 등
  - 시스템을 재사용할 있는 추상화 모델 (간단하고 공통된 모델)
    - 재사용>비즈니스>통합 가능, 재사용>앱>공통 컴포넌트
- 아키텍처 활동
  - 기능적 요구사항(RFP, 제안서, 기술협상, 키스택홀더): 시스템 구조 정의
  - 비기능적 요구사항(QA): ISO9126 등의 품질 요구사항 식별, 우선순위 결정 (유틸리티 분석 수행 - 중요도, 난이도 식별 목적)
  - 전술정의: 비기능적 요구사항 해결 방법, 측정 기준 및 방법
  - 재사용 컴포넌트: 재사용 / 공통 컴포넌트를 정의
  - 아키텍쳐 계층화: 레이어 계층을 정의, 인터페이스 식별 (OSI 7계층도 레이어 계층)
  - 뷰 포인트: 각자의 관점별로 이해할 수 있는 방법으로 제시할 것 (사용자, 분석/설계자, 개발자 등)
    - 소프트웨어 아키텍쳐 보고서 (IEEE1471)
  - 품질속성(비기능적 요구사항)
    - 품질속성 종류: 시스템, 비즈니스, 아키텍쳐
    - ISO9126(품질모델): 기능성, 사용성, 신뢰성, 효율성, 유지보수성, 이식성
      - 기능성: RFP에 나온 모든 요구사항을 만족, 완전을 준수하였는가
      - 사용성: 사용이 쉬운가, 예제 제시
      - 신뢰성: 결함이 없는가, 품질 목표가 제시가 결함율을 달성하였는가, 목표 결함률 준수 여부
      - 효율성: 제한된 자원 하에 처리량 극대화 가능한가
      - 유지보수성: 코딩이 표준화되어 있고 이해가 용이하고 주석이 있으며 모듈화가 되어있는 등
      - 이식성: 다른 환경에서 적용 가능한가, 윈도우/맥 등
  - 소프트웨어 아키텍처 평가
    - ATAM (Architecture Tradeoff Analysis Method): 아키텍쳐 품질요소 간의 상호작용 정의
    - CBAM (Cost Benefit Analysis Method)
      - 경제적 의사결정을 위한 아키텍쳐 분석의 경제적 모델링
      - 시나리오 정의, 효용/반응값, 이익계산, 아키텍처 선정 및 검증
  - 소프트웨어 아키텍처 스타일
    - MVC: 하나의 데이터를 다양한 뷰로 출력, 모델도 뷰도 확장 가능,
      - 다형성(Polymorphism), 오버로딩, 오버라이딩 2가지 유형 (컴파일/런타임 유형), 템플릿 메소드
    - Pipe Filter: 여러개 명령 동시 실행, 순차 처리와 병렬 처리 모두를 모델링
    - Layer Style
    - Repository: 공유 저장소
    - Publish Subscribe: MVC와 유사, EAI
    - Client-Server
    - Virtual Machine: Host OS, VM, VM 안의 OS (Guest OS), Vitualization, 하이퍼바이저, Docker
- 기타 작성 내용
  - 유틸리티 분석은 아래와 같음
  - 비기능적 요구사항:
    - 품질속성: 성능, 가용성(장애 시 바로 전환 등), 보안, 호환성 (이런 큰틀을 마련해준 것이 ISO9126)
    - 시나리오: 3초이내 응답, 주서버장애 시 5분 이내에 백업서버로 전환되어야 함, 전송구간은 암호화/고유식별자는 저장소 암호화, IE9이상 부터는 문제가 없어야 한다.
    - 중요도: 상
    - 난이도: 중
    - 우선순위: 상
  - 유틸리티 분석은 어떻게 평가하는가
    - 측정방법, 측정주기

## 객체지향 분석 / 설계

- 분석: 문제점 파악
- 객체지향 특성
  - 추상화:
    - 복잡>간략히 표현
    - 공통, 데이터, 기능 <-- 간략하게 표현하는 것 > 추상화 
  - 캡슐화: 속성과 연산인 클래스, 클래스가 캡슐화
    - 접근지정자 부여 가능, public, private, protected
  - 상속: 부모 클래스의 기능을 물려받음
  - 다형성: 동일한 메세지에 대해서 객체가 반응하는 특성, 동적 바인딩
- RUP 4+1 View
  - UseCase View: 사용자 요구사항 모델링, 명세
  - Logical View: 시스템 내부 (클래스) 구조 모델링
  - Process View: 프로그램, 프로세스 분할, 프로세스, 스레드 병행성, 런타임 환경
  - Implementaion View: 컴포넌트 그룹화
  - Deployment View: 서버 구성도, 컴포넌트가 노드에 배치
- BPR (Business Process Reengineering)
  - 업무 재설계하는 것을 의미
  - 유저 스토리, 내가 하는일, 시나리오(이벤트 플로우, 일하는 절차)
- 객체 지향 설계 원칙
  - 인터페이스 분리: 입출력의 인터페이스 분리, 입력 1개, 출력 1개 각각 인터페이스를 분리
  - 개방과 폐쇄: 확장은 가능, 변경되지 않은 구조 (MVC)
    - OPEN and CLOSED
    - Client 에서 sort() 호출 시 구현체에서 실제 동작함, 구현체만 증가시키면 확장 가능, 구조는 변화되지 않음
    - 호출은 연관관계, 구현은 실체화(다형성, 메소드이름을 동일하게 쓴다)
    - 전략 패턴 적용 시 다른 알고리즘 여러개 추가 가능
  - 단일책임 원칙: 모듈화 의미, 하나의 객체가 하나의 책임
  - 리스코프 치환원칙: 자식들은 부모 타입들이 사용되는 곳에 대체될 수 있어야 함.
    - 서브 클래스의 메소드로 대체될 수 있어야 함 (다형성 의미)
  - 의존관계 역전
    - 누가 누구를 종속하는가
    - 의존관계는 파생 클래스가 아닌 추상클래스

## UML

- UseCase
  - Actor, Usecase 상호작용 모델링
  - UseCase 명세서에 상세 내용 표기, UseCase 마다 명시
- Class Diagram
  - 정적 모델링, 클래스 속성, 행위, 서로간의 관계 모델링 (상속, 연관, 구현, 합성 등)
  - A라는 클래스가 있을 때 A클래스만 사용하는 경우, 아니면 다른 경우에도 사용하는 경우에 따라 표기 달라짐
  - Association: 의미적 링크
    - Aggregation: 전체와 부분을 표현
    - Composition: 같이 죽고 같이 산다, 생성자 때 같이 생성
  - Generalization: 상속
  - Dependency
  - Implementation
- Sequence Diagram
  - 세로는 시간, 세로 네모는 인스턴스 생명주기, 화살표 위 문구는 메소드
  - 라우팅, 비동기 표시, 메소드(행위)
- State Chart Diagram
  - 상태 전이, 객체의 상태변화를 표현, 이벤트 발생에 따른 변화
- Deployment Diagram
  - 시스템 물리적 구성, 제품의 이름까지 작성되어 있음
- Component Diagram
  - 소프트웨어 물리적 단위 모델링 (exe, dll 등), 프로그램

## Java Code 변환

- 클래스를 자바 코드로 자동 생성
  - Association: 전역변수
  - Dependency: 메소드 내 지역변수, 메소드 파라미터
  - Realication: implements
  - Generalization: extends
- MDA(Model Driven Architecture)
  - 메타 모델을 사용한 설계 모델의 재사용 기법
  - 메타 모델을 기반으로 구현환경에 독립적인 시스템을 개발하고 자동으로 구현 환경에 배치하는 방법으로 소프트웨어 개발
    - 메타데이터: 자원을 설명하는 데이터, Resource를 설명하는 데이터
    - 메타모델: 설명하는 데이터를 어떻게 집어넣느냐, 구조에 대한 건
  - 목적: 설계의 재사용
  - 참고: UML Profile: OCL (Object Constraint Language)
  - MOF(Meta Object Facility): 모델에 대한 표준 저장소
  - CWM(Common Warehouse Meta Model): 데이터 저장소에 대한 모델 데이터베이스 스키마 변환
  - XMI(XML Metadata Interface): XML변환, XML이 표준이니까 변환가능
  - UML Meta Model
  - UML Profile: 스테레오 타입 태그, 태그 값 정의, MOF 메타 모델
- MDD 개발 프로세스
  - CIM(Computation Independent Mode): 비즈니스 요구항을 추출
  - PIM(Platform Independent Model)
  - PSM(Platform Specification Model)
- Product Line
  - 도메인 공통 컴포넌트를 사용해서 소프트웨어를 개발하는 프로세스
- Product Line Process
  - Core Asset Development (Collabration)
  - Application Engineering
  - Management
    - 형상관리, 변경관리, 버전 컨트롤 시스템, 변경 최적화하고 관리하는 프로세스, 변경을 추적하는 프로세스, CCB(Change control board)
    - VCS: SVN(중앙집중형), GIT(분산형 워크플로우, 스토리지 2개)
    - IEEE 4Step: 식별, 통제, 감사, 기록
      - Configuration Identification (식별)
      - Configuration Control, CCB (통제)
      - Configuration Status Accounting (상태관리)
      - Configuration Audit (감사, 산출물 감사, Baseline Core Asset)
  - 모든 프로젝트에는 Management Set 이라는 것이 있음
    - Requirement Artifact (유스케이스 모델링, 명세서)
    - 클래스 다이어그램 등
    - 소스코드
    - 테스트 시나리오, 테스트 케이스
- Domain Engineering
  - 특정 도메인 내의 애플리케이션에서 공통 컴포넌트(Core Asset)을 생산하기 위한 프로세스
  - 도메인 분석/설계/구현
- Refactoring: 소프트웨어 기능은 변경하지 않고 로직을 개선하는 활동
  - 외부 기능은 변경하지 않고 내부 기능을 개선
  - 언제 하는게 좋은가? > 개선시점 설명하는 것 핵심
    - 버그가 발견될 때
    - 소프트웨어 가독성 (Read Ability) 향상 목적
    - 모듈화 통한 재사용하고자 할 때
    - Performance(성능) 개선 목적
    - TDD, 테스트를 반복적으로 수행할 때
  - 리팩토링 기법
    - 클래스 추출 등

## 중간 정리

- 소프트웨어 리엔지니어링: 소프트웨어 품질 문제 해결
- 소프트웨어 위기: 비용지연, 생산성 저하, 품질 저하를 체계적인 방법으로 해결
- 소프트웨어 프로세스 모델: 소프트웨어 개발 과정에 대한 일련의 절차, 표준
- Incremental 개발 모델: 버전을 추가하듯이 개발, 테스트를 지속한다.
- 공정이 우수하면 제품도 우수하다고 가정
- CMMI: 미국 카네디대 개발 소프트웨어 품질에 대한 성숙도 모델
- 요구사항: 기능적, 비기능적
  - 비기능적 (품질요구사항, 명시적, 암시적), 접근성 (장애인, 일반인 균등하게)
  - 명시적: 산출물 정의
  - 암시적: 제안, 문서화되어 있지 않음 
- 유스케이스 모델: 사용자와 상호작용 모델링
- 유스케이스 명세서 (유스케이스 아이디)
- 정적 모델링 클래스 (애트리뷰트 + 메소드)
  - 연관, 상속, 의존, 구현
- 시퀀스 모델 (시간에 따라)
- 리스코프의 교체 원칙 (부모클래스를 자식클래스로 대체해야한다.)
- 입출력을 인터페이스로 분리
- 오픈 앤 클로즈: 전략 패턴

## 요구공학

- 프레임워크
  - 개발
  - 관리
  - 도구들 (모델링 도구, 엑셀, 워드 등)
- 요구사항 Verification / Validation 방법
  - 리뷰, 워크스루, 인스펙션
  - 프로토타입 통한 확인
  - 스프린트(개발범위) 리뷰
    - 플래닝 게임(Planning Game):
      - 다음 스프린트의 반복과정을 오늘까지 협의
      - 고객과 협의해서 다음 반복을 무엇을 할지 협상하는 과정

## 제안요청서

- 활용분야
  - 발주, 검수기준, 
  - 제안PM, 제안전략 수립, 
  - 감리, 과입 이행여부 확인

## 프로토타이핑 제안전략

- 피엠 입장에서는 Man Month(MM)이 많이 든다.
- 사례가 없을 때 프로토타이핑 제안 가능

## 빅뱅과 나선형 모델

- 핵심: 리스크
- 리스트 완화 방법: 작은 단위 반복, PoC 진행

## 전자서명

- 5개의 키

## 비트코인 전자서명

- 내용 없음

## DrDoS

- SYN 패킷 탐지

## APT

- 지속적으로 죽을때까지
- 기본적으로 절차, 단계 4개 존재
- 공격기법
  - 스피어 피싱, 힙 스프레이
- APT 공격의 사례, 샌드박스 테스트

## 요구사항의 종류

- 정적
- 동적
- 기능적
- 품질 요구사항
- 기능, 비기능, 관리
  - 기능: 공통, 인터페이스
  - 비기능: 보안, 성능
  - 관리
- 요구사항 변경

## 망분리

- 기관 시설 사업자: 물리적 망분리 필요
- 망 연계 방법 (내부, 외부)
- 망 분리 시 메일 서버, 외부에서 내부 접근은 안된다
- 프린터: 스풀링이라는 것을 사용

## 테스트 (Test, Quality Control)

- 정의: 사전에 결함과 오류를 발견
- 기본적으로 품질 계획 수립
- SQPM (Software Quality Process Management) - 프로세스에 초점
  - 암시적
  - 명시적
- SQA 프로세스 (Software Quality Assurance Process) - 공정을 모니터링하는, 그 산출물을 관리하는 프로세스
  - 정의 (Quality Definition): 품질속성
  - 관리 (Quality Management): 계획, 품질 계획, 품질 보증 프로세스를 정의, 관리
  - 평가 (Quality Assessment): Verfication & Validation, Inspection, 인수테스트(사용자)
- 추가 설명:
  - Verfication
    - 공정에서 만든 산출물이 적합한지를 확인
  - Validation
    - 요구사항에 적합한 프로덕트/제품를 만들었는지를 확인
  - 요구사항 > 분석 > 설계 > 구현 > 유닛테스트(단위테스트) > 통합테스트 > 시스템 테스트 > 인수 테스트
    - Verification(프로세스 확인), Validation (테스트를 통해 제품을 확인)
    - Quality Assurance, Quality Control
    - 품질 보증, 품질 통제
    - 요구사항, 인수테스트
      - 기능적 / 비기능적, 고객이 사용, 알파테스트, beta테스트
    - 분석, 시스템 테스트
      - 요구사항 명세서 / 목표 성능 달성 여부 확인, 강도 최악의 시나리오 확인
      - 에이징, 보안(암호화, 접근권한, 권한 관리(Acceess Control)), Failover(가용성)
    - 설계, 통합 테스트
      - 클래스 모델링, 컴포넌트 / 모듈 간의 인터페이스 테스트(I/F 테스트), BDD, 드라이버(테스트 프로그램), Stub 필요 (Drive & Stub)
      - 모듈 > 모듈(Driver) > Stub
      - 테스트 자동화 프로그램 == 테스트 드라이버
    - 구현, 단위 테스트
      - 개발 / 가장 단위의 모듈을 확인(기능 확인), TDD, 화이트 박스 테스트 기법(안의 로직을 보면서 테스트), 통합테스트의 결함률을 낮추는 효과
  - Review(peer) 품질보증활동, 동료검토활동, Verification의 기법
    - Review: 자유롭게 검토하는 기법
    - Walkthrough: 리뷰보다는 공식화 정도가 높으나 공식화가 낮고(Inspection보다) 체크리스트를 사용한 검토
    - Inspection: 공식화 정보 높음, 체크리스트 사용, 중간에 목적 변경없음, 중재자 통해 진행
- 소프트웨어 테스트 설계 기법
  - 명세기반(블랙박스) 테스트
    - 형식적, 및 비형식적인 문제로 테스트 케이스를 유도
    - 동등분할, 결계 값, 의사결정(도메인(규칙)), 상태전이(조건, 행위에 대한 테스트) 등
  - 구조기반(화이트박스) 테스트
    - 코드와 디자인으로부터 테스트케이스 유도
    - 커버리지
    - 단위/통합/시스템 레벨
  - 경험기반 테스트
    - 경험 활용
  - 그레이박스
    - 블랙과 화이트 박스 혼합
  - 몽키 테스트
    - 랜덤 값으로 테스트
- 소프트웨어 테스트 절차
  - 테스트 계획 수립 - 성공의 기준, 80%이상이면 통과로 판단하겠다 등
  - 테스트 케이스 설계 - 시나리오, 입출금 ATM 기기를 예로 들어서 이해
  - 테스트 실행 및 측정
  - 결과분석 및 보고
  - 오류추적 및 수정

## Agile Process

- 애자일 프로세스와 방법론 구분 중요
  - 프로세스: 몇가지 원칙을 준수하는 것
  - 방법론: 스크럼, XP
- 애자일 프로세스 전제
  - 선언문 (Manifest)
    - 개인과 상호작용
    - 작동하는 소프트웨어
    - 고객과 협력
    - 변화에 대응 가능
  - 애자일 프로세스
    - 가변적인 요구사항에 대응하기 위해서 사람 중심의 프로세스
    - 구성요소: 선언문, 원칙, 프로세스, 방법론으로 구성
  - 방법론
    - 스크럼: 팀단위활동, Roles, 팀 단위 (2~4주 단위로) - 팀이 개발하니까, 리스크가 완화되는 효과, 스크럼의 목적은 팀관리, 팀단위 활동 강조
      - 팀단위 활동 중심의 애자일 프로세스
      - 제품 중심의 애자일 프로세스
      - (1) Product Backlog (요구사항, 유저스토리에서 추출, 비전과 요구사항 수집, 우선순위)
      - Product Owner (Key Stack Holder, 비전과 요구사항을 제시하는 사람)
      - (3) Sprint (2~4주 단위 반복 개발, 스프린트 개발)
      - (2) Sprint Backlog (요구사항 분할, 스프린트 선정)
      - (4) 스크럼 Review Meeting (개발팀 공유, 고객 참여, 확인, Planning Game)
      - Scrum Master (PO와 Scrum 멤버 중재자의 역할, 위험 관리 및 공유)
      - Daily Scrum (Daily Startup Meeting, 매일 서서 미팅, 불필요 시간 줄인다, 간략, 빠르게, 10~15분 정도, 어제한일, 오늘 할일, 리스크 공유)
    - XP (eXtreme Programming)
      - 커뮤니케이션, 단순성, 피드백, 용기를 기반으로 소프트웨어를 개발한 방법
      - 빠른 가치를 제공하겠다, 동작 소프트웨어를 빠르게 고객에게 주겠다, 빠른가치 > 분할
      - 빠른 피드백을 중요시
      - 공공 프로젝트 애자일 하면 안되는 이유
        - 고객이 팀원이 아니고 밖에 있으므로
        - 애자일을 쓸 경우 피엠의 역할이 중요 > 고객과 지속적인 소통해야 함
      - 4가지 특징 (5가지 특징)
        - 의사소통
        - 단순성(Simplicity)
        - 빠른 피드백
        - 용기 (Courage, 변화에 대응하는 자세)
        - (상호존중)
      - 12 Practice
        - On-Site Customer (고객참여)
        - Simple Design
        - Refactoring (개선, 가독성, 퍼포먼스, 개발 표준 준수, 다같이 개발하니까)
        - Pair Programming
          - (2인이 1개를 개발, 생산성 우수, 대화하면서 개발해라, 2인이 1개 개발하면 맨먼스 2개 들어감)
          - 초기에 페어프로그래밍 대상 업무를 선정해야 함, 비용을 무시할 수 없음
        - Collective Code Ownership
        - The Planning Game
        - Testing (TDD)
          - 테스트를 먼저해라
        - Continuous Integration
        - Small Releases
        - 40 hour week
        - Coding Standards
        - Metaphor~
    - TDD (Test Driven Development)
      - TDD 프로세스. 코드, 테스트, 리팩토링을 반복하는 프로세스/방법론
      - 중요포인트: 코드를 작성하기 전에 테스트 먼저 작성한다.
        - 설계 (구현가능한 모델)
          - 클래스 설계가 없으면 테스트 먼저 작성 불가
        - 테스트 (JUnit 생성)
          - JUnit 라이브러리추가, 단위테스트, (espresso (BDD, 행위테스트, 버튼 눌러서 UI 테스트))
          - class Test { TC001_SUM { class opreration myop; int ouput = myop.sum(10); AssertEquals(15, output); } }
          - TC002_SUM { ... AssertEquals(12, output); } <-- 의도적인 Fail 테스트
        - 코드 (개발 시작, 모델링 기반 개발)

## Agile 선언문(Manifest)

- 선언문 밑에 애자일 원칙이 있음
- 원칙
  - 빠른 피드백
  - 빠른 가치를 제공
  - 경량화된 프레임워크(F/W), 불필요 활동, 도구를 최소화
  - 가변적인 요구사항에 대응
- 이런 것들을 지키려다 보니 작은 단위로 개발
- 애자일 프로세스
  - 반복적 모델 사용, Incremental, Iterator, 1주(짧으면 짧을수록 리스크는 낮아진다)
- 애자일 리스크 관리 (애자일 위험 관리)
  - 최소단위 소프트웨어
  - 의사소통 (고객과 의사소통)
  - 개념증명 (PoC)
- 애자일 기본 구조
  - 선언문
  - 애자일 원칙
  - 애자일 프로세스
  - 애자일 위험 관리

## 소프트웨어 품질 (Software Quality)

- 주관적 문제점, 측정어려움, 시간에 따라 변화하는 문제
- 소프트웨어 품질
  - 개발과정 전체에 적용되는 보호 활동
  - 제품에 설정된 기술적 요구사항과 일치성을 확인하는 체계적인 활동
    - 기술적 요구사항과 일치성 > SQPM
- 품질관점 (Quality View)
  - 사용자: 다양한 기능 및 성능
  - 개발자: 표준에 맞는 프로그램
  - 유지보수자: 오류가 적고, 문서화, 이해용이성
  - 발주자: 유지보수 비용 최소화
- 품질측정 대상
  - 프로젝트: 진행관리, 측정지표, 진척율, 투입공수, 예산준수 (단계별 예산 필요 - 비용초과의 리스크 축소 가능)
    - EV(Earned Value), 범위 일정 고려 비용
  - 프로세스: 프로세스 성과 및 분석 관련 측정지표, 준수율, 결함 제거율, 인스펙션 효율성
    - 품질 보증 프로세스에 의해 관리되고 있는가
  - 프로덕트: 제품 품질평가, 규모, 복잡도, 품질특성, 재사용율 등
- 프로젝트 추청
  - Size
    - LOC, FP(Function Point, 기능이 어느정도 된다.)
  - Effort
    - MM, MH
- 소프트웨어 품질측정 방법
  - 크기 중심 매트릭스
    - LOC, (PERT), 원가/비용, Man-Month
  - 기능 중심 매트릭스
    - FP, 복잡성, 기능성, 신뢰성, 유지보수성, 효율성
- 소프트웨어 품질측정 방법 2번째
  - 직접법: LOC, FP, McCabe(회전 복잡도, 사이클론 매트릭스, 폐구간), Halstead 과학적 매트릭스(연산자, 피연산자 수)
    - 폐구간(if, for 등), 폐구간 + 1
    - 연산자 (A=B+A), 연산자: +, = 총 2개, 피연산자: A 2번, B 1번, 프로그램의 부피 계산
    - McCabe & Halstead : 예측을 못하는 전제\
    - PERT 라는 기법과 혼용해서 사용 가능
  - 간접법: 기능성, 사용성, 신뢰성
    - 품질 측정 절차 (모든 평가 절차는 아래 절차대로 진행)
      - 측정 목표 설정 (목표)
      - 픅정지표 정의 (지표)
      - 데이터 수집
      - 분석절차 정의
      - 측정결과 수집
      - 측정 데이터 분석
      - 결좌저장 및 공유
- SPI (Software Process Improvement) 프로세스 개선활동
  - 프로세스 개선, 공정 개선
  - 프로덕트, ISO-9162, GS인증
    - 프로세스, 프로덕트 > 프로세스 관리
    - ISO 12207
    - SPICE ISO-15504
    - CMMI (개발 조직의 성숙도 모델)
- Cost 추정 기법
  - 전문가 감정 (계획에 의한 추정법, 관리자에 의한 추정법)
  - 유사 추정 (과거 유사한 프로젝트와) (계획에 의한 추정법, 관리자에 의한 추정법)
  - 파라메터 (수학)
    - LoC, FP
  - 상향식 (Bottom-Up, WBS 법): 상세 추정법, 담당자에 의한 추정, 정확도 높으나 느림, WBS가 끝나야 알수있으니까
    - WBS --> Work Package 단위 (2주안에 완료할 수 있는 일) --> 전체로 확산
    - 정확도 높음, 요구사항이 명확하게 확정
    - 예측 단계에서 사용하기 어려움, 현실적 어려움
  - 3점 추정
    - PERT, CPM(1점 추정)
  - 입찰가(Bid, Vendor Bid)
- 품질모델 (Quality Model)
  - McCall의 Quality Model
    - 프로덕트 전환
    - 프로덕트 운영
    - 프로덕트 수정
  - Boehm의 Quality Model
    - 이식성
    - 사용성
    - 유지보수성
  - ISO 9126 품질특성
    - 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
  - FURPS+ (Compliance)
- ISO 품질관련 표준 모델
  - 제품관련 모델
    - ISO 9126
    - ISO 14598
    - ISO 12119
    - ISO 25000
    - GS(Good Software)
      - 우선 구매제도(분리발주), 국내 제품 소프트웨어 품질 특성, 성능평가
  - 프로세스 관련모델
    - ISO 12119
    - ISO 15504(SPICE): 2차원 구조의 능력인증 모델
    - Cmmi: 카네기멜론 대학교 SEI ~ 품질 성숙도 모델
      - SW-CMM, P-CMM, IPD-CMM등을 통합한 단일화된 모델
      - *PA: 변경/배포관리, 요구사항 개발/관리
      - 단계형
        - 초기>반복>정의>관리>최적
          - 초기(표준 X)
          - 반복(경험, 표준) -> 요구사항 개발
          - 정의(전사 표준) -> 변경관리, 배포관리, 모든 업무에 다 반복 적용
          - 관리(정량적 측정)
          - 최적(지속적 개선)
      - 연속형
    - SP(Software Process) 인증
      - 국내 중소기업을 위한 소프트웨어 프로세스 품질인증 모델(한국, 국내 사용 모델)