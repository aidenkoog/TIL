# Software Test

정리될 내용들은 아래와 같습니다.

- 개념 / 용어 정의, 사용 이유
- Interview Question, Answer
- CSTS, 정보처리기술사(테스트, 품질), 정보시스템감리사(소프트웨어 공학)

## 소프트웨어 테스트 전체 목차

- 소프트웨어 테스트 개요
- 블랙박스 테스트 (명세 기반 테스트)
- 화이트박스 테스트 (구조 기반 테스트)
- 테스트 계획 및 관리

## Software Test 개요

- 테스트 정의
  - Hetzel73: 프로그램이나 시스템이 자신이 해야 되는 일에 믿음을 주는 행위/과정 -> 신뢰성 확보
  - Glass79: 결과가 올바른지 판단하는 과정 (Test Oracle)
	- Test Oracle
		- Positive
		- Negative
  - Myers79: 에러를 발견할 목적으로 프로그램을 실행하는 과정
	- 동적 테스트
	- 정적 테스트
  - Craig and Jaskiel02: 품질 측정/개선위해 테스트웨어를 공학화하여 사용하고 유지하기 위한 또 다른 라이프사이클 프로세스
	- 품질측정 -> 품질 매트릭스
	- 테스트웨어 -> 테스트 시나리오 / 테스트케이스 / 테스트엔진(프로그램) / 스크립트 / 테스트데이터

- 소프트웨어 품질 특징
	- 소프트웨어 테스트 (ISO 9126): 소프트웨어가 가져야할 품질 항목이 무엇이냐를 정의한 것이 ISO 9126
		- 기능성: 요구사항
		- 사용성: 유저 인터페이스(UI), 반응형, Cross Browser
		- 신뢰성: 복잡도, 프로그램 복잡할 경우 결함 발생 확률 높음
		- 이식성: 환경, 다양한 환경 동작 가능성
		- 유지보수성: 표준화, 가독성, 이해용이성
		- 효율성: 제한된 자원으로 효과적 사용 가능성
	- ISO 14598
	- ISO 9126 + ISO 14598 = ISO 25000

- 소프트웨어 오류
  - 요구사항 오류: 잘못된 의사소통, 요구사항 누락 등
	- 제안요청서 및 인터뷰 등을 통해서 잘못된 요구사항을 정의
		- 기본적으로 정확하지 않은 요구사항
	- 사용자와 개발자간 의사소통
	- 시간 및 예산 등의 문제로 고의적 요구사항 누락
  - 설계오류: 설계과정에서 발생
  - 코딩오류: 개발 시 발생
	- 설계 문서 이해하지 못한 상태로 개발
	- 설계 반영 때 누락되어 개발까지 영향
	- 프로그래밍 언어/새로운 기술 등 익숙하지 않은 상태에서 개발
  - 기타오류: 문서 및 코딩 표준 미준수, 부족한 테스트
	- 코딩표준, SQL표준, 문서표준 등을 미준수
	- 충분하지 않은 테스트 프로세스

- Beizer의 소프트웨어 테스트 진화 과정
  - 레벨 1(Debugging-oriented): 디버깅
  - 레벨 2(Demonstration-oriented): 올바른 동작을 입증
  - 레벨 3(Destruction-oriented): 오류가 있음을 보여주는 테스트
  - 레벨 4(Evaluation-oriented): SDLC 전 단계에서 오류 테스트
  - 레벨 5(Prevention-oriented): 사전에 결함을 예방, 테스트 용이성 고려해야 함

- 테스트 용이성(Testability)
  - 제어용이성
  - 관찰가능성
  - 단순성
  - 분할용이성
  - 운영용이성
  - 안전성
  - 이해용이성

- 에러, 결함, 오작동 용어 정리
	- 에러(Error)
		- 사용자 실수(Mistake)
		- 사용자 요구사항을 잘못 파악, 잘못된 요구사항, 이해부족, 타이핑 실수, 잘못된 코딩
	- 결함(Fault)
		- 프로그램 내부에 잘못된 로직, Defect라고 함
		- 에러로 발생하는 잘못된 로직
	- 오작동(Failure)
		- 프로그램 실행결과와 사용자 기대결과 간 차이
		- 결함에 의해서 발생하나 결함이 있다고 반드시 오작동이 발생하는 것은 아님

## 개발단계에 따른 테스트 단계

- 단위 테스트: 모듈에 대한 확인, Test Stub과 Test Driver
- 통합 테스트: 모듈 간 통합 테스트
  - Big-bang, 점진적 테스트
  - 하향식 통합, 상향식 통합, 샌드위치
- 시스템 테스트: 시스템 전체, 비기능 확인
  - 사용성, 견고성, 신뢰성, 보안성, 성능
- 인수 테스트: 사용자 요구사항 만족여부
  - 알파와 베타 테스트
- 기타 테스트
  - 리그레션 테스트(Regression Test): 수정 후 테스트를 통해서 다시 확인
  - 스모크 테스트(Smoke Test)
	- 빌드 수준인지 확인하는 테스트
	- 중요한 기능 확인, 화면이동 등 테스트

- 소프트웨어 테스트 원칙
  - 원칙1, 테스트는 반드시 프로그램을 개발한 프로그래머나 팀과는 무관한 그룹에 의해서 수행되어야 함
  - 원칙2, 테스트 작업을 가장 능력이 뛰어난 사람에게 할당
  - 원칙3, 오류가 발견되지 않을 것이란 가정하에 테스트 계획을 수립해서는 안됨
  - 원칙4, 타당한 경우뿐만 아니라 타당하지 않고 예상하지 못한 경우들에 대해서도 테스트를 수행
  - 원칙5, 프로그램의 어떤 부분에 오류가 남아 있을 확률은 이미 발견된 오류의 수에 직접적으로 비례
  - 원칙6, 테스트케이스를 체계적으로 관리
  - 원칙7, 각각의 테스트 결과를 철저하게 점검

- 견고성 테스트: 시스템이 비정상적인 경우에도 얼마나 동작이 원활하게 이루어지는지 확인
- 신뢰성 테스트: 어느 기간동안 요구되는 서비스를 제공하는 능력을 측정
- 파레토 원칙: 시스템의 20%의 모듈들이 전 자원의 80%를 소비

## Test 종류: Data 및 Logic 기반

- 블랙박스 테스트
  - 요구사항을 기반으로 테스트
  - 입력에 대한 기대값 확인
  - 내부 지식이 없어도 가능

- 블랙박스 테스트 종류
  - 동등 클래스 분할
  - 경계값 분석
  - 도메인 테스트
  - 페어와이즈 조합
  - 상태전이 테스트
  - 인과 그래핑
  - 결정 테이블

- 화이트박스 테스트
  - 논리적 구조를 커버하는 테스트
- 화이트 박스 테스트 종류
  - 정적 테스트: 프로그램을 실행하지 않고 테스트
  - 동적 테스트: 프로그램 실행
- 화이트 박스 테스트 커버리지
  - 문장/블록 커버리지
  - 분기(결정) 커버리지
  - 조건 커버리지
  - 조건/분기 커버리지
  - 다중 조건 커버리지
  - 기본 경로 테스트
  - 변경조건/분기 커버리지
  - 자료흐름 테스트
- 정적 테스트
  - 동료검토: Walkthrough, Inspection
  - 공식검토
  - 정적분석: 심볼릭 분석, 자료흐름 분석

- 기본용어
  - Requirement: 사용자가 제품에게 요구하는 기능
  - Test Scenario: 테스트가 필요한 상황
  - Test Case
    - 테스트 입력 값
    - 입력 + 사전조건 > 사후조건 + 예상출력(Oracle)
  - Test Script
    - Test Case를 실행하기 위한 절차

## Test Plan (범위와 전략 수립)

- 테스트 프로세스
    - 테스트 계획: 테스트 계획서
    - 테스트 설계: 테스트 설계 명세서, 테스트 케이스 명세서, 테스트 절차서
    - 테스트 실행: 테스트 로그, 테스트 사건(오류) 보고서, 테스트 요약 보고서
    - 테스트 평가 및 개선: 테스트 평가 보고서
- 테스트 계획: 효과적이고 효율적인 테스트 진행을 위한 범위, 수행방법, 일정을 수립
- 테스트 계획 구성요소
    - 요구사항 명세서와 구조설계 명세서 기반
    - 테스트 일정, 테스트 수행자
    - 테스트 범위 및 항목, 테스트 전략 및 테스트 환경
    - 테스트 시작 및 종료기준
- 테스트 범위
- 단위 테스트
  - 제약조건으로 전체 모듈에 대한 단위 테스트가 어려움, 오류발생 가능성과 영향도가 높은 모듈을 집중적으로 관리, 상세설계 명세서를 활용
- 통합 테스트
  - 모듈 간 통합의 적절성 여부 판단, 복수 개의 모듈, 통합적 시나리오에 포함된 모듈
- 시스템 및 인수 테스트
  - 시스템을 구성하는 전체 모듈을 통합, 테스트 설계 명세서가 작성됨, 요구사항 명세서 확인
- 테스트 적합성 기준
  - 단위 테스트: 화면설계서, 상세 설명 명세서, 소스코드
  - 통합 테스트: 인터페이스 정의서, 구조 설계 명세서
  - 시스템 테스트: 프로세스 정의서, 요구사항 명세서
  - 인수 테스트: 테스트 요구사항 정의서, 고객 요구사항
- 적합성 점검 방법 및 도구
  - 생성된 테스트 케이스가 적합성을 충족하는지 확인 방법을 정의해야 한다
	- 커버리지 분석도구: 문장 커버리지
	- 검토/인스펙션, 요구사항 추적: 요구사항 명세서

## 테스트 자동화: 성능, 보안 약점, DB 무결성

- 자동화 도구 종류
  - 테스트 계획: 관리 및 노력예측 지원 도구
  - 테스트 분석 및 설계: 테스트 케이스, 데이터 생성도구, 커버리지 분석도구
  - 테스트 실행: 캡처/재생 도구, 메모리 테스트 도구, 성능 테스트 도구
  - 테스트 모니터링 및 통제, 평가 및 개선
    - 테스트 관리도구, 오류추적 지원도구

## 위험도 분석을 통한 테스트 전략: 위험 기반 테스트

- 테스트 전략
  - 위험 분석을 통해서 단계별 테스트 설계 방법을 결정
- 위험
  - 장래로 인해 주어진 기간에 발생하는 비용
  - 위험 = 장애(Failure) * 손실(Damage)
- 위험분석 절차
  - 위험식별, 발생 가능성 분석, 영향도 분석, 위험도 결정
- 위험 분석표 작성
  - 시나리오 도출: 테스트 시나리오 및 케이스, 명세서에서 시나리오 ID 도출
  - 가중치 결정: 테스트 대상에 대한 위험요소 별 가중치 적용
  - 위험수준 결정: 시나리오별 위험요소에 대한 위험수준 결정
  - 점수측정: 가중치와 위험수준을 통해 점수측정
  - 위험도 결정: 위험점수를 통해 위험도를 상/중/하로 구분
- 위험도 분석
  - 위험도 = 장애 발생 가능성 * 영향도
  - 장애발생 가능성: 결함이 많이 발생할 가능성
  - 영향도: 발생된 결함으로 손실 또는 시스템에 주는 영향
- 장애 발생 가능성 (예시)
  - 프로그램 복잡성, 프로그램 크기, 새로운 개발 정도, 적용기술 최신성
- 영향도
  - 사용빈도, 사용자 취급 중요도, 경제적 피해
- 위험점수 (예시)
  - 1점: 위험 없음, 2점: 위험 정도가 낮음, 3점: 위험 정도, 4점: 위험 정도가 높음, 5점: 위험 정도가 심각함
- 위험도 수준 (예시)
  - 상: 만점기준에서 80% 이상, 중: 20~80%, 하: 20% 미만
- 위험도 분석을 통한 테스트 설계

## 블랙박스 (Black Box): Data Driven

- 동등 클래스 분할
	- 프로그램의 입력 데이터에 예상되는 동등 클래스로 분할하고 대표 값을 선택하여 테스트케이스로 사용
	- 동긍 입력 값에서 오류가 발생하면 다른 값도 오류가 발생한다는 것을 가정
- 동등 클래스 분할 방법
	- 유효 값과 유효하지 않은 값
	- 양수, 음수, 0의 정수의 숫자 값
	- 공백이거나 데이터가 있는 문자열 값
	- 공백이거나 데이터 있는 리스트
	- 파일이 존재하거나 없는 상태 값
	- 데이터 파일의 종류
	- 파일 입출력 위치
- Positive Test: 유효한 입력 데이터를 사용
- Negative Test: 유효하지 않는 입력 값 사용
- 경계 값 분석 테스트
	- 경계 값을 포함시켜서 테스트케이스를 도출
	- 클래스 간의 경계, 경계 위, 아래의 값
	- 범위 끝에 속하는 유효 값과 바로 바깥 값을 선택
	- 입력 값의 최소 값과 최대 값, 최소 값과 최대 값의 아래와 위의 값을 선택
- 도메인 테스트
	- 입력 데이터가 상관관계가 있는 경우 상관관계에 따라 테스트 케이스를 도출
- 도메인 테스트 방법
	- ON 포인트
	- OFF 포인트
	- IN 포인트
	- OUT 포인트
	- 입력 변수에 대한 모든 조건을 도출 후 ON 포인트와 OFF 포인트를 선정하여 테스트
	- 테스트 하지 않은 다른 입력 값은 IN 포인트를 선정
	- 조건이 <=, >=, <, >인 경우 1개의 ON 포인트와 1개의 OFF 포인트를 선정
	- 조건이 = 인 경우, 1개의 ON 포인트와 2개 OFF 포인트를 선정
- 도메인 테스트 방법
	- 선정된 입력 값에 대한 예상결과를 포함하는 도메인 테스트 매트릭스 테이블을 생성
		- 변수, 조건, 테스트 케이스
- 페어와이즈(Pairwise) 조합 테스트
	- 모든 가능한 조합을 테스트 하지 않고 모든 짝(Pair)들의 조합을 테스트
	- 입력 갑의 모든 짝들의 테스트케이스 내에 한번 이상 들어가도록 테스트케이스를 도출
	- 가능한 모든 조합을 한 것과 비슷한 효과
	- 테스트케이스 도출 복잡도가 높음
- 상태전이 테스트
	- 상태 전이도를 기반으로 테스트케이스를 도출
- 상태전이 테스트 방법
	- 상태전이 모델링
	- 상태전이도로부터 전이 트리플 생성
	- 전이 트리로부터 각 전이 경로를 테스트하는 테스트케이스를 생성
	- 비정상적인 전이를 테스트하는 테스트케이스를 생성
- 결정 테이블
	- 입력 조건의 모든 조합에 대한 시스템 액션을 고려한 테스트케이스를 도출
	- 복잡한 논리적 관계 표현이 좋음
	- 누락된 요구사항 검사 시에 용이함
- 결정 테이블 방법
	- 시스템에 영향을 주는 조건을 분석한다.
	- 조건은 왼쪽 위에 행동은 왼쪽 아래에 위치시킨다.
	- 모든 조건의 조합을 나열하고 행동을 기입한다.
	- 일어날 수 없는 조건의 조합을 테이블에서 삭제 한다.
	- 동일한 행동을 유발하는 조건의 조합을 찾아서 테스트케이스를 줄인다.

## 화이트 박스 (White Box): Logic Driven

- 화이트 박스 테스트
	- 프로그램 소스코드의 논리적인 구조를 커버하도록 테스트케이스를 설계하는 방법
- 정적 테스트 기법
	- 소프트웨어를 실행하지 않고 테스트
	- 동료검토, Walkthrough, Inspection, 공식검토 등
	- 정형검증, 코딩 규칙 검증
- 동적 테스트
	- 화이트 박스 테스트 및 블랙박스 테스트
- 제어 흐름도(Control Flow Graph)
	- 프로그램의 제어구조를 표현한 그래프
	- 노드와 간선으로 구성
	- 노드: 단일 문장 또는 문장들의 집합
	- 기본블록: 문장들의 집합을 노드로 표현하는 경우 이를 기본블록(Basic Block)이라고 함
	- 간선: 완전경로(실선), 부분경로(점선)
- 제어 흐름도 기본용어
	- 결정 포인트(Decision Point): 분기 노드로 if, while, for, switch 문
	- 전체 조건식(Total Condition): 소스코드 내에서 결정 포인트 내의 모든 조건식
		- if 문 혹은 while에 있는 if(x>0 && y<1)
	- 기본 조건식(Indivisual Condition)
		- 전체 조건식에 연산자로 구분되어 있는 각각의 조건식
- 제어흐름 테스트
	- 소스코드의 논리흐름에 초점을 맞추는 테스트 적합성을 기준
- 자료흐름 테스트
	- 소스코드에서 변수가 정의되고 그 정의된 변수가 어디에서 사용되는지에 초점을 맞추는 테스트 적합성 기준

## 화이트 박스 커버리지 (테스트 충분성)

- 문장 커버리지(Statement/Block Coverage)
	- 테스트 하는 프로그램 내의 모든 문장을 적어도 한번 이상 실행
	- 문장 커버리지 = 테스트케이스에 의해 실행된 문장의 수 / 전체 문장의 수 * 100
- 분기(결정) 커버리지(Branch Coverage)
	- 결정 포인트가 참과 거짓을 적어도 한번 이상 실행하게 시키는 테스트케이스를 설계
	- 분기 커버리지를 만족하면 문장 커버리지도 만족
	- 분기 커버리지 = 테스트케이스에 의해 실행된 분기 수 / 전체 분기 수 * 100
- 조건/분기 커버리지(Condition/Decision Coverage)
	- 프로그램에 나타난 각 기본조건들의 참과 거짓 및 각 전체 조건의 참과 거짓이 적어도 한번 테스트되도록 테스트케이스를 설계
	- 실행된 기본 + 전체 조건식의 T, F수 / 모든 기본 + 전체 조건식의 T, F수 * 100
- 다중 조건 커버리지(Multiple Condition Coverage)
	- 프로그램의 각 조건문 내 기본 조건식의 가능한 논리적 조합이 적어도 한번 테스트 되도록 테스트케이스를 도출하는 기준
	- 다중 조건 커버리지 = 실행된 기본 조건식의 T, F수 / 모든 기본 조건식의 T, F 모든 조합의 개수 * 100
- 커버리지 비교
	- 다중 조건 > MC/DC > 조건/분기 > 분기(결정) & 조건
		- 분기(결정) > 문장 커버리지
	- 테스트케이스 수 증가(테스트 실행 비용 증가) > Fault 증가

## 기본경로 커버리지

- 기본 경로 커버리지
	- McCabe가 제안한 방법으로 사이클로매틱 복잡도(Cyclomatic complexity)의 개수 만큼의 경로를 테스트케이스로 도출
	- 프로그램 내의 모든 독립적인 경로를 테스트한다.
- 기본경로 (Basis Path)
	- 프로그램 내의 다른 기본경로들과 선형적으로 독립적인 경로
	- 집합을 구성하는 기본경로의 개수는 해당 프로그램의 사이클로매틱 수와 같음
- 사이클로매틱 복잡도
	- 주어진 논리 흐름 그래프에서 선형적으로 독립적인 프로그램 경로들의 개수
- 사이클로매틱 복잡도 계산
	- E-N+2 (E: 간선 수, N: 노트 수)
	- 폐구간(Closed region: 둘러 쌓인 곳) + 1
	- 분기 노드의 개수 + 1
- 사이클로매틱 복잡도의 의미
	- 프로그램 이해와 유지보수 등이 얼마 어려운지 판별한다
	- 3~7 정도의 값은 잘 구조화된 프로그램
	- 10이하의 복잡도를 갖도록 구성 필요
- 기본경로 집합 도출 기법
	- 단순 기본경로 기법
		- Simplified Baseline Path Technique
		- 가장 짧은 기본 경로부터 도출한다.
	- 실용 기본경로 기법
		- Practical Baseline Path Technique
		- 가장 긴 기본경로부터 도출한다.

## 정적 테스트(Static Text): 프로그램을 실행하지 않고 테스트

- 동료검토(Peer Review)
	- 기술적 내용이나 품질을 평가하기 위해 저자와 동료에 의해서 산출물을 평가하는 소프트웨어 검토 방법
	- 결함과 개선을 발견하기 위해서 개발 당사자를 제외한 동료가 검토
	- 1.Walkthrough
		- 개발 작성물을 작성하는 중에 검토
		- 초기에 오류를 발견하고 해결
		- 개발 산출물 작성자에 의해서 진행
		- 비형식적인 기법
	- 2.Inspection
		- 개발 초기단계부터 결함을 발견
		- 공식적인 활동
		- 비슷한 직급을 가진 사람으로 구성
		- 주재자, 검토자, 작성자, 기록자, 판독자, 테스터
		- 계획, 개요, 준비, 회의, 프로세스 개선, 재작업, 후속작업
- 동료검토 목적
	- 산출물이 요구사항을 충족하는지
	- 사전에 결함을 발견 및 제거
	- 위험을 감소하고 신뢰성을 확보
- 공식검토(Formal Review)
	- 개발단계 종료 시점에서 산출물에 대해서 수행하는 정적 테스팅 방법
	- 검토결과에 따라 다음 단계 진행여부를 결정
	- 관리자, 주재자, 작성자, 검토자, 기록자
	- 계획, 킥오프, 개별준비, 리뷰회의, 재작업, 후속작업
	- 1.요구사항 검토(SRR)
	- 2.예비설계 검토(PDR)
	- 3.상세설계 검토(CDR)
	- 4.테스트 준비, 검토(TRR)
- 정적분석
	- 심볼릭(실행 가능, 경로분석), 자료흐름 분석(자료흐름의 이상패턴 분석)
- 심볼릭
	- 프로그램의 입력변수를 기호화하여 표시한다
	- 심볼릭 실행 트리를 통해서 주어진 경로가 실행가능한지를 검사한다(PC: Path Condition)
	- 경로조건을 만족시키는 값들이 가능한지를 검사한다.
	- 경로조건을 만족시킬 수 없는 실행 불가능한 경로를 찾는다.
- 자료흐름분석
	- 자료 흐름 상에 이상패턴이 있는지 확인한다.

## Verification, Validation

- 검증(Verification)
	- 프로그램 정확도, 프로세스, 서비스 또는 문서들이 명시된 요구사항을 따르는지를 재검토, 조사, 시험, 검사
	- 감리 및 문서화를 하는 행위
	- 소프트웨어 개발주기에 있어서 주어진 단계에서의 제품이 이전 단계에서 수립된 요구들을 수행하는 가를 결정하는 과정
	- 제품을 올바르게 만들고 있는가?
- 확인(Validation)
	- 소프트웨어의 요구의 만족을 보장하기 위해 소프트웨어 개발 프로세스의 끝부분에서 소프트웨어를 평가하는 과정
	- 시험 및 객관적인 증거 제시로 특정요소에 대한 특별한 요구사항이 만족됨을 확인
	- 옳은 제품을 만들고 있는가?
- V Diagram
	- 요구사항 정의 > 설계 > 코딩 > 단위 시험 정의/설계 > 단위시험 실행 > 통합시험 실행 > 시스템시험 실행 > 인수시험 실행

## 소프트웨어 테스트 관련 질의 응답

- 시스템이 어느 기간 동안에 요구되는 서비스를 제공하는 능력을 측정하기 위한 테스트 기법
	- 신뢰성 테스트
- 유지보수 단계에서 소프트웨어가 수정된 후에 변경이 올바르게 되었는지 검사하는 테스트 기법
	- 리그레이션 테스트
- 빌드가 될 수준인지 확인하는 테스트
	- 스모크 테스트
- 시스템이 비정상적인 경우에도 얼마나 동작이 원활하게 이루어지는가를 테스트하는 것
	- 견고성 테스트
- 인스펙션 설명
	- 동료 검토 방법 중 가장 공식적인 형태로 개발 산출물을 완성본을 대상으로 결함을 찾기 위해 수행하는 검토 회의
	- 정식 검토 규정과 프로세스가 존재하며, 체크리스트를 기반으로 훈련된 리더가 회의를 중재한다.
- 워크쓰루 설명
	- 작성 중인 개발 산출물(중간)을 대상으로 주로 작성자의 요청에 의해 회의가 이루어지며 중재되는 다소 비형식적인 검토방법
	- 참가자의 역할 구분이 명확하지 않으며 참가자는 작업물의 개요 정도만 파악한 후 회의에 참석
	- 정식 검토 프로세스가 존재하지 않으면 자유롭게 토론하고 결함을 찾는 검토회의
- 테스트 계획 구성요소 중 하나인 테스트 접근방법(전략) 수립 시 필요한 고려사항
	- 개략적인 테스트 기법, 테스트 적합성 기준, 테스트케이스 준비방법, 테스트 실행방법
	- 오류기록/추적방법, 테스트 자동 방법 등을 고려해야 한다.
- 각 테스트 활동별 테스트 산출물(문서)
	- 테스트 계획 - 테스트 계획서
	- 테스트 분석 및 설계 - 테스트 케이스
	- 테스트 실행 - 테스트 요약 보고서
	- 테스트 평가 및 개선 - 테스트 평가 보고서
- 테스트 수준별 테스트 수행 정상 여부에 대한 기준 문서 관계
	- 단위테스트: 소스코드, 화면 설계서, 상세 설계 명세서
	- 통합테스트: 요구사항 명세서, 프로세스 정의서
	- 시스템테스트: 요구사항 명세서
	- 인수테스트: 고객의 요구사항, 테스트 요구 정의서

## 명세기반-결정테이블

- 정의
- 장점
- 단점

## 상태 전이 테스팅

- 정의
- 상태 전이 다이어그램 (STD, State Transition Diagram)
- 상태 전이 테스팅을 통한 테스트 설계 방식
- 상태 전이 테스팅으로 발견 가능한 결함
- 상태 전이 테스팅 기반 테스트 케이스 도출 순서

## 테스트 산출물 종류 및 설명

- 테스트 산출물은 개발 주기와 테스트 목적에 따라 다를 수 있지만, 일반적으로 다음과 같은 문서들이 포함됩니다

- 테스트 계획서 (Test Plan)
  - 목적: 테스트의 전체적인 방향성과 범위를 정의.
  - 내용:
    - 테스트 목적과 목표.
	- 테스트 범위 (기능 테스트, UI 테스트, 성능 테스트 등).
	- 테스트 유형 (단위 테스트, 통합 테스트, 시스템 테스트 등).
	- 테스트 환경 (OS, 브라우저, 하드웨어, 네트워크 조건 등).
	- 테스트 일정 (주요 마일스톤).
	- 테스트 도구 및 프로세스 (e.g., Selenium, JIRA).
	- 리스크 및 해결 방안.
	- 담당자 역할 분담.
	- 출력물: 프로젝트 초기 단계에 작성.

- 테스트 케이스 (Test Cases)
  - 목적: 각 테스트 시나리오와 절차를 상세히 기술.
  - 내용:
	- 테스트 케이스 ID (고유 식별자).
	- 테스트 시나리오 (어떤 기능을 테스트하는지).
	- 사전 조건 (테스트를 실행하기 위한 준비 사항).
	- 테스트 절차 (단계별 테스트 방법).
	- 예상 결과 (예상 출력 및 시스템 반응).
	- 실제 결과 (테스트 실행 후 기록).
	- 성공 여부 (Pass/Fail).
	- 출력물: 기능 단위, 화면 단위, 또는 프로세스 단위로 작성.

- 테스트 결과 보고서 (Test Report)
  - 목적: 테스트 결과를 요약하고, 발견된 문제 및 개선 사항을 보고.
  - 내용:
	- 테스트 개요 (테스트 수행 기간, 테스트 환경).
	- 테스트 실행 현황 (수행한 테스트 케이스 수, 성공/실패 비율).
	- 주요 발견된 결함 및 심각도.
	- 결함 상태 (Open, Fixed, Retested).
	- 잔여 리스크 및 추가 작업 필요성.
	- 결론 및 다음 단계 제안.
	- 출력물: 테스트 종료 후 작성.

- 결함 추적 보고서 (Bug/Issue Tracking Report)
  - 목적: 발견된 결함을 기록하고 해결 상태를 추적.
  - 내용:
	- 결함 ID (고유 식별자).
	- 발견 일자.
	- 발견된 기능 및 모듈.
	- 문제의 설명 (재현 절차 포함).
	- 우선순위 및 심각도.
	- 상태 (Open, In Progress, Closed).
	- 담당자.
	- 출력물: 테스트 중 지속적으로 작성.

- 테스트 시나리오 (Test Scenario)
  - 목적: 테스트의 주요 흐름과 사용자 관점에서의 테스트를 정의.
  - 내용:
	- 사용자 관점의 시나리오 (e.g., “사용자가 로그인 후 장바구니에 제품 추가”).
	- 주요 기능 및 관련 케이스.
	- 출력물: 테스트 계획 단계에 작성.

- 산출물 작성 방법
  - 간단명료하게 작성: 방대한 문서보다는 빠르게 작성하고 이해할 수 있는 문서가 중요합니다.
  - 협업 툴 활용: Google Sheets, Notion, JIRA 등으로 작성하면 팀 간 실시간 공유가 편리합니다.
  - 템플릿 재사용: 표준 템플릿을 사용하여 시간을 절약하고 품질을 높입니다.