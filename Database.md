# 데이터베이스

정리될 내용들은 아래와 같습니다.

- 개념 / 용어 정의, 사용 이유
- Interview Question, Answer

## 데이터베이스 전반 요약 선 정리

- 정보 시스템
  - 데이터를 수집, 저장 했다가 필요시 정보를 생성하고 분배하는 수단
  - 경영정보, 군사정보, 인사행정 정보, 의사결정 지원 시스템 등으로 사용됨
  - 용어
    - 자료: 관찰이나 측정으로 수집한 사실이나 결과값 (가공되지 않은 상태)
    - 정보: 자료를 가공해서 얻은 결과물
    - 자료처리 시스템: 정보 시스템이 사용할 자료를 처리하는 서브시스템 (일괄처리, 온라인 실시간처리, 분산 처리)시스템으로 분류
    - 데이터웨어 하우스: 주요 업무 시스템에서 새로 생성된 DB로서 의사결정 지원 시스템을 지원하는 주체적, 통합적, 시간적 데이터의 집합체다.

- DB 정의 (통합, 저장, 운영, 공용 데이터)
  - 통합 데이터: 자료 중복을 배제한 자료
  - 저장 데이터: 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
  - 운영 데이터: 업무수행에 없어서는 안될 반드시 필요한 자료
  - 공용 데이터: 공동으로 소유하고 유지하는 자료

- DB 특징
  - 실시간 접근성: 질의에 실시간으로 응답이 가능
  - 계속적인 변화: 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지
  - 동시공유: 동시에 여러 사용자가 데이터를 이용할 수 있음
  - 내용에 의한 참조: 사용자가 요구하는 내용으로 데이터를 찾음

- DBMS 정의
  - 사용자의 요구에 정보를 생성하고 DB를 관리해 주는 소프트웨어
  - 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로 모든 응용 프로그램이 DB를 공용할 수 있도록 관리해 준다.
  - DB의 구성, 접근방법, 유지관리에 대한 모든 책임을 진다.

- 기존의 파일처리 방식의 문제점
  - 종속성의 문제점: 저장되는 방법이나 접근방법을 변경할 때 모두 바꿔줘야 한다.
  - 중복성의 문제점: 일관성, 보안성, 경제성, 무결성

- DBMS 필수기능
  - 정의: 데이터의 형식과 구조, 데이터가 DB에 저장 될때 제약조건등을 명시하는 기능
  - 조작: 삽입, 삭제, 갱신, 요청을 처리하기 위해 데이터 접근 수단 등을 정하는 기능
  - 제어: 무결성 유지, 보안 유지, 권한 검사, 정확성을 유지 하도록 병행 제어를 할 수 있어야한다.

- DBMS 장/단점
  - 장점       
    - 데이터 중복 예방
    - 자료를 공동으로 이용가능
    - 일관성, 무결성, 보안, 최신의 데이터를 유지 할 수 있음
    - 데이터 표준화 및 통합하여 관리 할 수 있음
    - 실시간 처리가 가능
    - 논리적 물리적 독립성이 보장
  - 단점 
    - DB 전문가 부족으로 전산화 비용이 증가
    - 디스크에 집중적인 접근으로 과부하 발생
    - 파일의 예비와 회복이 어려움
    - 시스템이 복잡함

- 스키마 정의 (스키마 = 메타데이터)
  - DB의 구조와 제약조건에 관한 전반적인 명세를 기술한다.
  - DB를 구성하는 개체, 속성, 관계 및 제약조건 등에 관해 전반적으로 정의한다.
  - 외부, 내부, 개념 스키마로 나뉜다.
  - 데이터 사전에 저장되며, 메타 데이터라고도 한다.

- 스키마 3계층
  - 외부 스키마
    - 논리적 구조를 정의한다.
    - 하나의 DB에 여러 외부 스키마가 존재가능하며, 하나의 외부 스키마를 여러 응용 프로그램이나 사용자가 공용할 수 있다.
    - 같은 DB에 대해서도 서로 다른 관점을 정의 할 수 있다.
  - 개념 스키마
    - 데이터를 통합 한 조직 전체의 데이터베이스로 하나만 존재
    - 개체간의 관계와 제약조건을 나타내고 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다.
    - 단순히 스키마라 하면 개념 스키마다
    - 기관이나 조직체의 관점에서 DB를 정의한 것이다.
    - DB관리자에 의해서 구성된다.
  - 내부 스키마
    - 물리적 저장장치와 밀접한 계층이다.
    - 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마다
    - DB의 물리적 구조를 정의한다.
    - 데이터의 실제 저장 방법을 기술한다.

- DDL
  - DB를 구축하거나 수정할 목적으로 사용하는 언어다.
  - 번역한 결과가 데이터 사전이라는 특별한 파일에 여러개의 테이블로 저장된다.
  - 기능
    - 외부 스키마 명세 정의
    - DB의 논리적 데이터 구조와 물리적 데이터 구조의 정의 및 수정
    - 논리적 데이터와 물리적 데이터 구조간의 사상정의
    - 스키마에 사용되는 제약조건에 대한 명세 정의
    - 데이터의 물리적 순서 규정

- DML
  - 응용 프로그램과 DBMS간의 인터페이스를 제공한다.
  - 사용자가 DB의 데이터를 조작할 수 있도록 하기위해 C, COBOL등의 호스트 언어에 DB기능을 추가시켜 만든 언어다.
  - 대표적으로 질의어가 있으며 터미널에서 주로 이용하는 비절차적 데이터 언어다.

- DCL
  - 무결성, 권한 제어, 회복 등을 하기위한 언어
  - 데이터 보호와 관리를 목적으로 사용된다.
  - 기능
    - 데이터 보안
    - 데이터 정확성을 위한 무결성 유지
    - 장애에 대비한 데이터 회복과 병행수행 제어

- DBA
  - DB운영에 대한 모든 관리와 책임을 지고있는 사람이나 그룹을 의마한다.
  - 데이터 모델 정의
    - 현실의 정보들을 컴퓨터에 표현하기 위한 개념적 모형이다.
    - 현실 세계를 DB에 표현하는 중간 과정
    - DB 설계 과정에서 데이터의 구조를 논리적으로 표현하기 위해 사용되는 도구

- 개념적 데이터 모델
  - 추상적 개념으로 표현하는 과정
  - 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법
  - 현실에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 떄문에 정보 모델이라 한다.
  - 개체 ㅡ 관계 (E - R) 모델이 있다.

- 논리적 데이터 모델
  - 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터 세계의 환경에 맞도록 변화하는 과정
  - 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법
  - 데이터 모델이라고 하면 논리적 데이터 모델을 말한다.
  - 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계, 계층, 네트워크 모델로 구분된다.

- 데이터 모델에 표시할 사항
  - 구조: 데이터 구조 및 정적 성질을 표현
  - 연산: 실제 데이터를 처리하는 방법을 표시하는 것으로 DB를 조작하는 기본 도구
  - 제약조건: DB에 저장될 수 있는 실제 데이터의 논리적인 제약조건을 표시

- 데이터 모델의 구성 요소
  - 개체(Entity)
    - DB에 표현하려는 것으로 개념이나 정보 단위 같은 현실 세계의 대상체
    - 유형, 무형의 정보로 서로 연관된 몇 개의 속성으로 구성
    - 파일 시스템의 레코드에 대응하는 것으로 정보를 제공하는 역할을 수행한다.
    - 현실에 독립적으로 존재하거나 그 자체로서도 구별이 가능하다.
  - 속성(Attribute)
    - 데이터의 가장 작은 논리적 단위로 파일 구조의 데이터 항목 또는 데이터 필드에 해당된다.
    - 개체를 구성하는 항목
  - 관계(Relationship)
    - 개체 간의 관계 또는 속성 간의 관계

- 개체 ㅡ 관계 모델 (Entity - Relationship)
  - 개념적 데이터 모델의 대표적인 모델 1976년 Peter Chen에 의해 제안
  - 개체타입과 이들간의 관계타입을 이용해 현실 세계를 개념적으로 표현
  - 데이터를 개체, 관계, 속성으로 묘사한다.
  - E ㅡ R 다이어그램으로 표현한다.
  - 특정 DBMS를 고려한 것이 아니라서 관계 표현에 제한이 없다.

- E ㅡ R 다이어그램
  - E - R 모델의 기본적인 아이디어를 시각적으로 표현하기 위한 도구이다.
  - 사각형: 개체타입
  - 마름모: 관계타입
  - 타원: 속성
  - 밑줄타원: 기본키 속성
  - 복수타원: 복합 속성
  - 관계: 개체 관계에 대해 선 위에 대응수 기술

- 관계형 데이터 모델
  - 계층 모델과 망 모델의 복잡한 구조를 단순화 시킨 모델
  - 테이블을 이용해 데이터 상호 관계를 정의하는 DB 구조를 말함
  - 데이터 간의 관계를 기본키와 이를 참조하는 외래키로 표현한다.
  - 대표적인 DBMS로 오라클, MS-SQL, Informix 등
  - 관계를 자유롭게 표현 할 수 있다.
  - 장점: 간결하고 보기가 편하며 다른 DB로 변환이 용이함
  - 단점: 성능이 다소 떨어짐

- 계층형 데이터 모델
  - 논리적 구조가 트리형태이고 개체가 트리를 구성하는 노드 역할을 한다.
  - 개체 집합들 사이의 관계를 링크로 연결한다.
  - 개체 간의 관계를 부모와 자식 간의 관계를 표현한다.
  - 개체 타입 간에 상위와 하위 관계가 존재하며 1:N 대응 관계만 존재한다.
  - 레코드 삭제시 연쇄 삭제가 된다.
  - 개체 타입들 간에는 사이클이 허용되지 않는다.
  - 계층형 모델에서는 개체를 세그먼트라 부른다.
  - 대표적인 DBMS는 IMS다.

- 망(그래프, 네트워크)형 데이터 모델
  - CODASYL DBTG 모델이라고도 한다.
  - 그래프를 이용해 데이터 논리 구조를 표현한 데이터 모델이다.
  - 상위와 하위 레코드사이에서 N:M 대응 관계를 만족하는 구조이다.
  - 상위의 레코드를 Owner, 하위 레코드를 Member라 하여 O - M 관계라고도 한다.
  - 대표적인 DBMS: DBTG, EDBS, TOTAL 등

- DB 설계 시 고려사항
  - 무결성 유지: 연산 후에도 데이터가 정해진 제약조건을 항상 만족해야 함
  - 일관성 유지: 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함
  - 회복성 유지: 장애 발생시 장애 발생 직전의 상태로 복구할 수 있어야 함
  - 보안성 유지: 데이터 노출 또는 변경이나 손실로부터 보호할 수 있어야 함
  - 효율성 유지: 응답시간 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
  - DB확장성 유지: DB 운영에 영향을 주지 않고 지속적으로 데이터를 추가 할 수 있어야 함

- 개념적 설계(정보 모델링)
  - 다른 사람과 통신하기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
  - 스키마 모델링과 트랜잭션 모델링을 병행하여 수행한다.
  - 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성한다.
  - DBMS에 독립적인 개념 스키마를 설계한다.

- 논리적 설계(데이터 모델링)
  - 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정
  - 논리적 구조의 데이터로 모델화한다.
  - 개념 스키마를 평가 및 정제하고 특정 DBMS에 종속적인 논리적 스키마를 설계하는 단계이다.
  - 트랜잭션의 인터페이스를 설계한다.
  - 관계형 DB라면 테이블을 설계하는 단계이다.

- 물리적 설계(데이터 구조화)
  - 논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정
  - DB 파일의 저장구조, 레코드의 형식, 접근경로와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.
  - 트랜잭션을 작성한다.
  - 설계 단계에 꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근경로 등

- 물리적 설계시 고려사항
  - 인덱스의 구조
  - 레코드의 크기 및 개수
  - 파일에 대한 트랜잭션의 갱신과 참조 성향
  - 성능 향상을 위한 개념 스키마의 변경 여부 검토
  - 빈번한 질의와 트랜잭션들의 수행속도를 높이기 위한 고려
  - 시스템 운용시 파일 크기의 변화 가능성

- 물리적 설계 옵션 선택 시 고려사항
  - 반응시간: 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과시간
  - 공간 활용도: DB파일과 액세스 경로 구조에 의해 사용되는 저장공간의 양
  - 트랜잭션 처리량: 단위 시간 동안 DB 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수

- DB설계 순서
  - 요구분석 > 개념적 설계 > 논리적 설계 > 물리적 설계 > 구현

- Relation 구조
  - Relation은 데이터들의 테이블의 형태로 표현한 것
  - 튜플(Tuple)
    - 릴레이션을 구성하는 각각의 행
    - 속성의 모임으로 구성된다.
    - 파일 구조에서 레코드와 같은 의미
    - 튜플 수 = Cardinality = 기수 = 대응수
  - 속성(Attribute)
    - 릴레이션을 구성하는 각각의 열
    - DB를 구성하는 가장 작은 논리적 단위
    - 파일 구조상 데이터 항목 또는 데이터 필드에 해당됨
    - 개체의 특성을 기술한다.
    - 속성의 수 = Degree = 차수
  - 도메인(Domain)
    - 하나의 속성에 취할 수 있는 같은 타입의 원자 값들의 집합
    - 속성값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데 이용된다.

- Relation Instance
  - 속성들에 데이터 타입이 정의되어 구체적인 데이터 값을 갖고 있는 것을 말한다.

- Relation 특징
  - 한 Relation에 포함된 Tuple들은 모두 상이하다.
  - 한 Relation에 포함된 Tuple사이에는 순서가 없다.
  - Tuple들의 작업으로 인해 Relation은 시간에 따라 변한다.
  - Relation 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
  - 속성의 식별을 위해 속성의 명칭은 유일해야 하지만 속성을 구성하는 값은 동일한 값이 있을 수 있다.
  - Relation을 구성하는 Tuple을 식별하기 위해 속성들의 부분집합을 키로 설정한다.
  - 속성은 원자값만을 저장한다.

- Key 개념 및 종류
  - 키는 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 속성이다.
  - Candidate Key
    - 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합, 기본키로 사용할 수 있는 속성들을 말함
    - 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다.
    - 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.
  - Primary Key
    - 후보키 중에서 선택한 주키
    - 한 릴레이션에 특정 튜플을 유일하게 구별할 수 있는 속성
    - NULL값을 가질수 없다.
    - 동일한 값이 중복되어 저장할 수 없다.
  - Alternate Key
    - 후보키가 둘 이상일때 기본키를 제외한 나머지 후보키들을 말함
    - 보조키라고도 함
  - Super Key
    - 릴레이션을 구성하는 모든 튜플중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
    - 릴레이션을 구성하는 모드 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
  - Foreign Key
    - 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구
    - 참조 테이블의 기본키에 없는 값은 입력할 수 없음
  - 무결성(Integrity)
    - 개체 무결성: 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없음
    - 참조 무결성: 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함
    - 도메인 무결성: 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정

- 관계대수의 개요
  - 관계형 DB에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 언어이다.
  - 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결과도 릴레이션이다.
  - 질의에 대한 해를 구하기 위해 연산의 순서를 명시한다.
  - 순수 관계 연산자와 일반 집합 연산자가 있다.

- 순수 관계 연산자
  - DB에 적용할 수 있도록 개발된 관계 연산자
  - Select
    - 선택조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듬
    - 릴레이션의 행에 해당하는 튜플을 구하는 것이라 수평연산이라고도 함
    - 연산자의 기호는 그리스 문자 시그마를 사용한다.
  - Project
    - 속성 List에 제시된 속성만을 추출하는 연산
    - 릴레이션의 열에 해당하는 속성을 추출하는 것이라 수직 연산자라고도 함
    - 연산자의 기호는 그리스 문자 파이를 사용한다.
  - Join
    - 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
    - 연산자의 기호는 ▷◁를 사용함
  - Division
    - X ⊃ Y인 2개의 릴레이션일때 Y가 가진 속성을 제외한 X의 속성만을 구하는 연산

- 관계해석
  - E.F Codd가 수학의 술어 해석에 기반을두고 관계 DB를 위해 제안
  - 비절차적 특성을 지님
  - 원하는 정보를 정의할 때 계산 수식을 사용함(질의어로 표현)
  - 튜플 관계해석과 도메인 관계해석이 있음
  - 관계해석과 관계대수는 관계 DB를 처리하는 기능과 능력 면에서 동등하다.

- 정규화(Normalization)
  - 개요
    - 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 과정
    - 제(1, 2, 3, BCNF, 4, 5)정규형이 있고 차수가 높아질수록 만족시켜야 할 제약조건이 늘어남
    - 정규화는 논리적 설계 단계에서 수행한다.
    - 논리적 처리 및 품질에 큰 영향을 미친다.
  - 목적
    - 데이터 구조의 안정성을 최대화한다.
    - 어떠한 릴레이션이라도 DB내에 표현 가능하게 만든다.
    - 효과적인 검색 알고리즘을 생성할 수 있다.
    - 중복을 배제하고 작업에대한 이상 발생을 방지한다.
    - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임

- Anomaly의 개념 및 종류
  - 정규화를 거치지 않고 DB에 데이터들이 불필요하게 중복되어 릴레이션 조작시 발생하는 현상이다.
  - 속성들 간의 존재하는 여러 종속 관계를 하나의 릴레이션에 표현하기 때문에 이상이 발생된다.
  - 종류
    - Insertion Anomaly: 데이터 삽입시 원하지 않은 값들도 함께 삽입되는현상
    - Delete Anomaly: 튜플을 삭제 할 때 관계없는 값들도 함께 삭제되는 연쇄 삭제 현상
    - Update Anomaly: 속성값을 갱신할 때 일부 튜플만 갱신되어 정보에 모순이 생기는 현상

- 정규화 과정
  - 도메인 원자값 => 부분적 함수 종속제거 => 이행적 함수 종속제거 => 결정자이면서 후보키 아닌 것 제거 => 다치 종속제거 => 조인종속성 이용

- SQL 분류 (DDL, DML, DCL)
  - DDL
    - 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어
    - DB 관리자나 DB 설계자가 사용한다.
    - 3가지 유형
      - CREATE: 스키마, 도메인, 테이블, 뷰, 인덱스를 정의함
      - ALTER: 테이블에 대한 정의를 변경함
      - DROP: 스키마, 도메인, 테이블, 뷰, 인덱스를 삭제함
  - DML
    - 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용하는 언어
    - DB 사용자와 DB 관리 시스템 간의 인터페이스를 제공한다.
    - 4가지 유형
      - SELECT: 테이블 조건에 맞는 튜플을 검색
      - INSERT: 테이블에 새로우 튜플을 삽입
      - DELETE: 테이블에서 조건에 맞는 튜플을 삭제
      - UPDATE: 테이블에서 조건에 맞는 튜플의 내용을 변경함
  - DCL
    - 데이터 보안, 무결성, 회복, 병행수행 제어등을 정의하는 데 사용하는 언어
    - DB 관리자가 데이터 관리 목적으로 사용함
    - 종류
      - COMMIT: 수행된 결과를 물리적 디스크로 저장하고 조작 작업이 정상적으로 완료 되었음을 관리자에게 알려줌
      - ROLLBACK: 조작 작업이 비정상적으로 종료되었을 때 이전 상태로 복구함
      - GRANT: DB 사용자에게 권한을 부여함
      - REVOKE: DB 사용자의 권한을 취소함

- SELECT문
  - SELECT Predicate 속성명 FROM 테이블명 [WHERE 조건] [GROUP BY 속성명] [HAVING 조건] [ORDER BY 속성명 [ASC | DESC] ];
  - SELECT절
    - Predicate
    - 불러올 튜플 수를 제한할 명령어를 기술함
    - ALL(모든 튜플검색 생략가능), DISTINCT(중복된 튜플 첫 번쨰 한개만 검색), DISTINCTROW(튜플 전체를 대상으로 검색)
  - 속성명
    - 검색하여 불러올 속성 및 수식들을 지정함
    - 모든 속성을 지정 할 때는 *, 두개 이상의 테이블을 대상으로 검색할 떄는 반드시 [테이블명.속성명]으로 표현한다.
  - FROM절
    - 질의에 의해 검색될 테이블명을 기술함
  - WHERE절
    - 검색할 조건 기술
  - GROUP BY절
    - 그룹화 할 속성을 지정함 보통 그룹 함수와 함께 사용된다.
  - 종류
    - COUNT(속성명): 그룹별 튜플 수
    - MAX(속성명): 그룹별 최대값
    - MIN(속성명): 그룸별 최소값
    - SUM(속성명): 그룹별 합계
    - AVG(속성명): 그룹별 평균
    - HAVING절
      - GROUP BY와 함꼐 사용되며, 그룹에 대한 조건을 지정함
    - ORDER BY절
      - 정렬을 오름차순, 내림차순으로 검색할때 사용함
      - ASC는 오름차순, DESC는 내림차순, 생략시 ASC

- 삽입문    
  - INSERT INTO 테이블명(속성명) VALUES(데이터);
  - 기본 테이블에 새 튜플을 삽입할 떄 사용한다.
  - 속성과 데이터의 개수 형식이 일치해야한다.
  - 모든 속성을 사용할 때는 속성명을 생략 할 수 있다.
  - SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있다.

- 삭제문
  - DELETE FROM 테이블명 WHERE 조건;
  - 모든 레코드를 삭제할 경우 WHERE절을 생략한다.
  - 모든 레코드를 삭제해도 테이블의 구조는 남아있어 DROP과는 다르다.

- 갱신문    
  - UPDATE 테이블명 SET 속성명 = 데이터 WHERE 조건;
  - 특정 튜플의 내용을 변경할 떄 사용한다.

- 내장 SQL
  - 응용 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어로 만든 프로그램에 삽입된 SQL이다.
  - 실행문이 나타날 수 있는 곳이면 어느 곳에서나 사용할 수 있다.
  - 일반 SQL문은 여러개의 튜플을 반환하지만 내장 SQL은 단 하나의 튜플만 반환한다.
  - 내장 SQL문에 의해 반환되는 튜플은 일반 변수를 사용하여 저장할 수 있음
  - 호스트 프로그램의 컴파일 시 내장 SQL문은 선행 처리기에 의해 분리되어 컴파일된다.
  - 호스트 변수와 DB필드의 이름은 같아도 된다.
  - 내장 SQL문에 사용된 호스트 변수의 데이터 타입은 이에 대응하는 DB 필드의 SQL 데이터 타입과 일치해야한다.
  - 내장 SQL문이 실행되면 SQL의 실행 상태가 상태 변수에 전달된다.
  - 호스트 언어 실행문과 SQL문 구분법
    - 명령문 구분: C/C++은 $와 ;사이에 기술, Visual BASIC에서는 SQL문 앞에 EXEC SQL을 기술
    - 변수로 구분: 내장 SQL에서 사용하는 호스트 변수는 변수 앞에 ':'을 붙임

- 뷰
  - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상테이블
  - 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
  - 데이터의 임시적인 작업을 위한 용도로 활용한다.
  - 특징
    - 기본테이블과 같은 형태와 구조를 가지며 조작도 거의같다.
    - 가상테이블이라 물리적으로 구현되어 있지 않음
    - 필요 데이터만 뷰로 정의할 수 있어 관리가 용이하고 명령문이 간단해진다.
    - 조인문의 사용을 최소화하여 사용상의 편의성을 최대화한다.
    - 뷰에 나타나지 않는 데이터는 안전하게 보호할 수 있다.
    - 기본키를 포함한 속성 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신, 연산이 가능함
    - 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음
    - 뷰를 삭제하면 그 뷰를 기초로 정의된 뷰도 자동으로 삭제된다.
  - 장점
    - 논리적 데이터 독립성을 제공
    - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원한다
    - 데이터 관리를 간단하게 해준다.
    - 접근 제어를 통한 자동 보안이 제공
  - 단점
    - 독립적 인덱스를 가질 수 없음
    - 뷰의 정의를 변경할 수 없음
    - 뷰로 구성된 내용에대한 작업에 제약이 따른다.

- 뷰 정의문
  - CREATE VIEW 뷰이름[속성이름] AS SELECT문;
  - SELECT문의 부질의로 사용하여 결과로서 뷰를 생성한다.
  - 부질의로 SELECT문에서 UNION이나 ORDER BY절은 사용 못함
  - 속성 이름을 기술하지 않으면 SELECT문의 속성 이름이 자동으로 사용된다.

- 뷰 삭제문
  - DROP VIEW 뷰이름 {RESTRICT | CASCADE};
  - RESTRICT: 뷰를 다른 곳에서 참조하고 있으면 삭제가 취소된다.
  - CASCADE: 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제

- 시스템 카탈로그
  - 스키마 및 다양한 객체에 관한 정보를 포함하는 시스템 DB이다.
  - 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지관리하는 시스템 테이블이다.
  - DB 구조 및 통계 정보를 저장한다.
  - 카탈로그가 생성되면 자료사전에 정장되기 때문에 자료사전이라고도 한다.
  - 카탈로그에 저장된 정보를 메타 데이터라고 한다.
  - 특징
    - 시스템 테이블로 구성되어 있어 SQL을 이용하여 내용을 검색해 볼 수 있다.
    - INSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않는다.
    - DBMS가 스스로 생성하고 유지한다.
    - 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신된다.

- 트랜잭션
  - DB상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 일련의 연산들을 의미한다.
  - 복구 및 병행 수행 시 처리되는 작업의 논리적 단위이다.
  - 하나의 트랜잭션은 COMMIT 되거나 ROLLBACK된다.
  - 일반적으로 회복의 단위가 된다.
  - 특징
    - 원자성, Atomicity
      - 트랜잭션의 연산은 모두 반영되든지 아니면 전혀 반영되지 않아야 함
      - 명령은 반드시 완벽히 수행되어야 하며, 에러가 발생하면 트랜잭션 전부가 취소되어야 함
    - 일관성, Consistency
      - 트랜잭션이 성공적으로 완료되면 일관성 있는 DB 상태로 변환함
      - 트랜잭션 수행전과 수행완료 후의 상태가 같아야 함
    - 고립성, lsolation
      - 수행중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에 끼어들수도 수행 결과를 참조할 수도 없음
    - 내구성, Durability
      - 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

- COMMIT 연산
  - 트랜잭션에 대한 작업이 성공적으로 끝났고 DB가 다시 일관된 상태에 있을 때 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

- ROLLBACK 연산
  - 비정상적으로 종료되어 DB의 일관성이 깨졌을 때 트랜잭션이 행한 모든 연산을 취소시키는 연산으로 해당 트랜잭션을 재시작하거나 폐기함

- 트랜잭션의 상태
  - Active: 실행중에 있는 상태
  - Failed: 오류가 발생하여 중단된 상태
  - Aborted: 비정상 종료되어 ROLLBACK 연산을 수행한 상태
  - Partially Committed: 트랜잭션이 마지막 연산까지 실행했지만 COMMIT연산이 실행되기 전의 상태
  - Committed: 성공적으로 종료되어 COMMIT연산을 실행한 후의 상태

- 회복
  - 트랜잭션 처리를 수행하는 도중 장애 발생으로 DB가 손상되어 그 이전 정상 상태로 복구시키는 작업
  - 장애유형
    - 트랜잭션 장애: 트랜잭션 내부 비정상적인 상황으로 인해 프로그램 실행이 중지되는 현상
    - 시스템 장애: 시스템 장애로 인해 트랜잭션의 연속적인 수행에 장애를 주는 현상
    - 미디어 장애: 저장장치인 디스크의 손상 및 헤드 충돌 등으로 DB의 일부 또는 전부가 물리적으로 손상된 상태

- 회복 관리기
  - DBMS의 구성 요소이다.
  - 트랜잭션이 장애로 인해 완료되지 못하면 이전 정상 상태로 복구하는 역할을 담당한다.
  - 메모리 덤프, 로그를 이용하여 수행한다.

- 회복 기법의 종류
  - 연기 갱신 기법 (Deferred Update)
  - 즉각 갱신 기법 (Immediate Update)
  - 그림자 페이지 대체 기법 (Shadow Paging)
  - 검사점 기법 (Check Point)

- 병행 제어
  - DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것
  - 문제점
    - Lost Update: 같은 자료를 공유하여 갱신할 때 결과의 일부가 없어지는 현상
    - Uncommitted Dependency: 트랜잭션 수행이 실패 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상
    - Inconsistency: 두개의 트랜잭션이 병행수행할때 원치 않는 자료를 이용함으로써 발생하는 문제
    - Cascading Rollback: 병행 수행되던 트랜잭션들 중 하나가 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상
  - 목적
    - DB의 공유를 최대화한다.
    - 시스템 활용도를 최대화 한다.
    - DB의 일관성을 유지한다.
    - 사용자에 대한 응답시간을 최소화한다.

- Locking
  - 주요 데이터 액세스를 상호 배타적으로 하는 것이다.
  - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 락을 요청해서 락이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법

- Locking Granularity (세분성)
  - 병행 제어에서 한꺼번에 로킹할 수있는 데이터 단위
  - DB, 파일, 레코드, 필드 등은 로킹 단위가 될 수 있다.
  - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행수준이 낮고 단위가 작으면 로크수가 많아 관리하기 복잡하지만 병행성 수준이 높다

- DB 보안의 개요
  - DB의 접근 권한이 없는 사용자가 액세스를 수행하는 것을 금지하기 위해 사용되는 기술
DB 사용자들은 일반적으로 서로 다른 객체에 대하여 다른 접근 권리 또는 권한을 갖게된다.

- 무결성과 보안
  - 무결성은 권한이 있는 사용자로부터 DB를 보호하는 것이고 보안은 권한이 없는 사용자로부터 DB를 보호하는 것
  - 무결성은 정확하게 사용할 수 있도록 보장하는 것이고 보안은 사용자들이 DB를 사용하고자 할 때 언제든지 사용할 수 있도록 보장하는 것

- 암호화 기법
  - 개인키 암호 방식 = 비밀키 암호 방식
  - 동일한 키로 데이터를 암호화하고 복호화한다.
  - 비밀키는 3자에게 노출하지 않고 DB사용 권한이 있는 사용자만 나누어 가진다.
  - 대칭 암호 방식 또는 단일키 암호화 기법이라 한다.
  - DES가 대표적이고 56Bit 16개 키를 이용하여 64Bit의 평문 블록을 16회의 암호 계산 단계를 거쳐 64Bit의 암호문을 얻는다.
  - 장점: 암호화/복호화 속도가 빠르며 알고리즘이 단순하고 파일 크기가 작음
  - 단점: 사용자 증가에 따라 관리해야 할 키의 수가 상대적으로 많아짐
  - 공개키 암호 방식
    - 서로 다른 키로 데이터를 암호화하고 복호화한다.
    - 데이터를 암호화할 때 사용하는 공개키는 DB 사용자에게 공개하고 복호화 할 때의 비밀키는 관리자가 비밀리에 관리하는 방법
    - 비대칭 암호 방식이라고도하며 대표적으로 RSA가 있다.
    - 장점: 키의 분배가 용이하고 관리해야 할 키의 개수가 적음
    - 단점: 암호화/복호화 속도가 느리며, 알고리즘이 복잡하고 파일 크기가 큼

- 분산 DB
  - 논리적으로 하나의 시스템에 속하지만 물리적으로 네트워크를 통해 연결된 여러개의 컴퓨터 사이트에 분산되어 있는 DB를 의미한다.
  - 4대목표
    - Location Transparency (위치 투명성)
      - 액세스하려는 DB의 실제 위치를 알 필요없이 논리적인 명칭만으로 액세스할 수 있음
    - Replication Transparency (복제 투명성)
      - 여러 곳에 중복으로 데이터가 있어도 사용자는 하나의 데이터만 존재하는 것처럼 사용하고 시스템은 자동으로 여러 자료에 대한 작업을 수행함
    - Concurrency Transparency (동시성 투명성)
      - 분산 DB와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
    - Failure Transparency (실패 투명성)
      - 장애에도 불구하고 트랜잭션을 정확하게 처리함
  - 장점
    - 지역 자치성, 효융성과 융통성, 신뢰성 및 가용성이 높음
    - 자료의 공유성, 시스템 성능이 향상
    - 분산 제어가 가능하고 점증적 시스템 용량 확장이 용이함
  - 단점
    - DBMS가 수행할 기능이 복잡함
    - 처리비용, 소프트웨어 개발 비용, 잠재적 오류가 증가함
    - DB설계가 어려움

- 자료 구조의 분류
  - 선형구조: 선형 리스트, 연결 리스트, 스택, 큐, 데크
  - 비선형구조: 트리, 그래프

- Linked List
  - 자료들을 임의의 기억공간에 기억시키되 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조
  - 노드의 삽입, 삭제 작업이 용이하다.
  - 기억공간이 연속적으로 놓여있지 않아도 저장이 가능함
  - 연결을 위한 링크 부분이 필요해 순차 리스트에 비해 기억공간 이용 효율이 좋지 않음
  - 접근 속도가 느리다.
  - 중간 노드의 연결이 끊어지면 그 다음 노드를 찾기 힘들다.
  - 희소 행렬을 링크드 리스트로 표현하면 기억장소가 절약된다.

- Stack
  - 리스트 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
  - 가장 나중에 사입된 자료가 가장 먼저 삭제되는 후입선출 방식 (LIFO: Last-In, First-Out)
  - TOP: 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소 스택 포인터라고도 함
  - Bottom: 스택의 가장 밑바닥
  - PUSH: 스택에 자료를 입력하는 명령
  - POP: 스택에서 자료를 출력하는 명령
  - 용도
    - 부 프로그램 호출 시 복귀주소를 저장할 때
    - 함수 호출의 순서 제어
    - 인터럽트가 발생하여 복귀주소를 저장할 때
    - 후위 표기법으로 표현된 산술식을 연산할 때
    - 0 주소지정방식 명령어의 자료 저장소
    - 재귀 프로그램의 순서 제어
    - 컴파일러를 이용한 언어 번역 시

- Queue
  - 선형 리스트 한쪽은 삽입 작업 다른 한쪽은 삭제 작업이 이루어지는 구조
  - 창구 업무 서비스 순서나 운영체제의 작업 스케줄링등에 사용된다.
  - 시작과 끝을 표시하는 두 개의 포인터가 있다.
  - 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 방식 (FIFO, First-In, First-Out)
  - 프론트 포인터: 가장 먼저 삽입된 자료의 기억공간을 가리키는 포인터 삭제 작업을 할 때 사용함
  - 리어 포인터: 가장 마지막에 삽입된 자료가 위치한 기억장소를 가리키는 포인터로 삽입 작업을 할 때 사용함

- Deque
  - 삽입과 삭제가 양쪽 끝에서 모두 발생할 수 있는 자료 구조
  - Double Ended Queue의 약자
  - 스택과 큐의 장정만 따서 구성한 것
  - 입력이 한쪽에서 발생하고 출력이 양쪽이거나 입력이 양쪽에서 일어나고 출력은 한쪽에만 이루어지는 제한이 있다.
  - 입력 제한 데크: Scroll
  - 출력 제한 데크: Shelf

- Tree
  - Node와 Branch를 이용하여 사이클을 이루지 않도록 구성한 Graph의 특수한 형태
  - 노드: 트리의 기본요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것
  - 근노드: 트리의 맨 위에 있는 노드
  - 디그리: 각 노드에서 뻗어나온 가지의 수
  - 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수
  - 단말 노드 = 잎 노드: 자식이 하나도 없는 노드
  - 비단말 노드: 자식이 하나라도 있는 노드
  - 자식 노드: 어떤 노드에 연결된 다음 레벨의 노드들
  - 부모 노드: 어떤 노드에 연결된 이전 레벨의 노드
  - 형제 노드: 동일한 부모를 갖는 노드들
  - 레벨: 근 노드의 레벨을 1로 가정한 후 어떤 레벨이 L이면 자식 노드는 L+1이다.
  - 깊이: 트리에서 노드가 가질 수 있는 최대의 레벨

- 이진 트리의 운행법
  - Preorder 운행: Root => Left => Rfight 순
  - Inorder 운행: LEFT => Root => Right 순
  - Postorder 운행: LEFT => Right => Root순

- 수식의 표기법
  - Prefix: 연산자 => Left => Right 
  - Infix: Left  => 연산자 => Right
  - Postfix: Left  => Right  => 연산자

- Infix 표기를 Postfix로 바꾸기
  - 연산 순서에 따라 괄호를 묶는다.
  - 연산자를 해당 괄호의 뒤로 옮긴다.
  - Postfix으로 바꾼 후 괄호를 제거한다.

- Infix 표기를 Prefix로 바꾸기
  - 연산 순서에 따라 괄호로 묶는다.
  - 연산자를 해당 괄호의 앞으로 옮긴다.
  - Prefix으로 바꾼 후 괄호를 제거한다.

- Postfix 표기를 Infix로 바꾸기
  - 인접한 피연산자 2개와 오른쪽의 연산자를 괄호로 묶는다.
  - 연산자를 해당 피연산자의 가운데로 이동시킨다.
  - 괄호를 제거한다.

- Sort
  - 파일을 구성하는 각 레코드들의 특정 키 항목을 기준으로 오름 또는 내림차순으로 재배열하는 작업

- 내부 정렬
  - 소량의 데이터를 주기억장치에만 기억시켜 정렬하는 방식
  - 종류
    - 히프, 삽입, 셸, 버블, 선택, 퀵, 2-Way Merge, 기수 정렬

- 외부 정렬
  - 대량의 데이터를 보조기억장치에 기억시켜 정렬하는 방식, 대부분 병합 정렬 기법으로 처리
  - 종류
    - 밸런스, 캐스케이드, 폴리파즈, 오실레이팅 병합 정렬

- 이분 검색(이진 검색)
  - 제어 검색의 일종인 이분 검색은 순서화된 파일이어야 검색할 수 있다.
  - 탐색 효율이 좋고 탐색 시간이 적게 소요됨
  - 전체 파일을 두 개의 서브 파일로 분리해 가면서 키 레코드를 검색하기 떄문에 검색 대상이 되는 데이터의 수가 절반씩 줄어든다.
  - 찾고자 하는 키 값을 파일의 중간 레코드 키 값과 비교하면서 검색한다.
  - 중간 레코드 번호 = (첫 번째 레코드 번호 + 마지막 레코드 번호)/2

- Hashing
  - 해쉬 테이블이라는 기억공간을 할당하고 해시 함수를 이용하여 레코드 키에대한 해쉬 테이블 내의 홈 주소를 계산한 후 주어진 레코드를 해당 기억장소에 저장하거나 검색 작업을 수행하는 방식이다.
  - DAM 파일을 구성할 때 해싱이 사용되며 접근 속도는 빠르지만 기억공간이 많이 요구됨
  - 검색 방식 중 검색 속도가 가장 빠르다.
  - 삽입, 삭제 작업의 빈도가 많을 때 유리한 방식
  - 키 ㅡ 주소 변환 방법이라고 한다.

- Hash Table
  - 레코드를 1개 이상 보관 할 수 있는 홈 버킷들로 구성한 기억공간으로 보조기억장치나 주기억장치에 구성할 수 있다.
  - 버킷: 하나의 주소를 갖는 파일의 한 구역읠 의미하고 버킷의 크기는 같은 주소에 포함될 수 있는 레코드 수를 의미함
  - 슬롯: 1개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함
  - Collision: 2개 이상의 레코드가 같은 주소를 갖는 현상
  - Synonym: 같은 홈 주소를 갖는 레코드들의 집합
  - Overflow: 버킷 내에 저장할 기억공간이 없는 상태, 버킷을 구성하는 슬롯이 여러 개일 떄 충돌현상은 발생해도 Overflow는 발생하지 않을 수 있음

- Sequential File
  - 입력되는 데이터들이 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록되는 방식
  - 변동 사항이 크지 않고 기간별로 일괄 처리를 주로 하는 경우에 적합
  - 주로 자기 테이프에서 사용된다.
  - 장점
    - 기록 밀도가 높아 기억공간의 효율적으로 사용가능
    - 레코드가 키 순서대로 편성되어 취급이 용이
    - 매체 변환이 쉬워 어떠한 매체에도 적용 가능
    - 키 순서대로 레코드를 처리하는 경우 다른 편성법보다 처리 속도가 빠르다.
  - 단점
    - 파일에 새로운 레코드를 삽입, 삭제, 수정하는 경우 파일 전체를 복사해야 하므로 시간이 많이 소요됨
    - 검색 시 처음부터 순차진행이라 검색 효율이 낮다.

- Indexed Sequential File
  - 순차, 랜덤 처리가 가능하게 키 값 순으로 정렬시켜 기록하고 레코드의 키 항목만을 모은 색인을 구성하여 편성하는 방식
  - 색인을 이용한 순차접근 방법이라 ISAM(Index Sequential Access Method)라고도 한다.
  - 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 직접 참조 가능
  - 일반적으로 자기 디스크에 많이 사용되며, 자기 테이프에서는 사용할 수 없다.

- 색인 순차 파일의 구성
  - Prime Area: 실제 레코드들을 기록하는 부분으로 레코드는 키 값 순으로 저장
  - Index Area: 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로 트랙, 실린더, 마스터 색인 구역으로 구분할 수 있음
  - Overflow Area: 기본 구역에 빈 공간이 없어서 새 레코드의 삽입이 불가할 때를 대비하여 예비로 확보해 둔 부분
  - Cylinder Overflow Area: 실린더마다 만들어지는 오버플로 구역으로 기본 구역에서 오버플로된 데이터를 기록함
  - Independent Overflow Area: 실린더 오버플로 구역에 더 이상 데이터를 기록할 수 없을 때 사용하는 예비 공간으로 별도로 만들어짐
  - 장점
    - 순차, 랜덤 처리와 목적에 따라 융통성 있게 처리가능
    - 효율적인 검색과 레코드의 삽입, 삭제, 갱신이 용이함
  - 단점
    - 색인과 오버플로우 구역을 구성하기 위해 추가 기억공간이 필요
    - 파일이 정렬되어있어야 하고 추가, 삭제가 많으면 효율이 떨어짐
    - 색인을 이용한 액세스라 액세스 시간이 랜덤 편성 파일보다 느림


## 정규화 정의

- 데이터베이스 내의 데이터 구조를 조직화하고 최적화하는 과정
- 데이터 중복을 제거하고 효율성을 향상시키며, 데이터 무결성을 보장하기 위한 목적을 가짐

## 정규화 이상 현상 종류

- 정규화를 거치지 않은 데이터에서 발생할 수 있는 현상
- 종류
  - 삽입 이상 (Insertion Anomaly): 데이터 삽입 시 의도와 다른 값들도 삽입
  - 삭제 이상 (Delete Anomaly): 데이터 삭제 시 의도와 다른 값들도 연쇄 삭제
  - 갱신 이상 (Update Anomaly): 속성값 갱신 시 일부 튜플만 갱신되어 모순 발생

## 정규화

- 1NF (제 1정규형)
  - 테이블(릴레이션)에 각 도메인은 원자성(Atomicity)를 가짐, 단일값
  - 각 컬럼이 하나의 속성, 각 컬럼이 원자값(하나의 값)을 가지도록 하는 과정
  - 하나의 컬럼은 같은 종류나 타입의 값을 가져야 함
  - 각 컬럼은 하나의 데이터만 저장하며, 다중 값을 가지지 않는다.
  - 각 컬럼이 유일한 이름을 가져야 함
  - 컬럼의 순서가 상관없어야 함
  - 데이터 중복이 줄어들어 공간적 효율성 향상
  - 1행에 홍길동, 2행에 홍길동, 이순신 이라는 값이 있을 때 1행과 2행에 데이터의 중복 발생 해결
  - 여러개의 값으로 인해 데이터 무결성(정확성, 일관성, 신뢰성) 보장 문제 해결
  - 여러개의 값 존재로 인해 전반적으로 구조 불분명한 이슈 해결
  - 삭제 연산 시 의도하지 않은 행이 삭제될 가능성 해결
  - 수정 연산 시도 마찬가지, 해결
  - 삽입 연산 시 이상문제가 발생할 수 있다는 점은 이해되지 않은 상태, 스터디 더 필요
- 2NF (제 2정규형)
  - 1NF 충족된 상태에서 진행
  - 1NF를 완료한 테이블에서 부분 함수 종속성을 제거하는 과정
  - 현재 테이블의 주제와 관련없는 컬럼을 다른 테이블로 빼는 작업
  - 완전 함수 종속을 만족하도록 테이블 분해하는 것
  - 완전 함수 종속이라함은 기본키의 부분집합이 결정자가 되어선 안됨, 즉 여러개의 조합인 기본키의 일부로 다른 컬럼의 값을 결정하면 안됨
  - 제 1정규화 때 하나의 컬럼 내 여러개의 값이 존재하던 것을 하나로 쪼갰었고 쪼개게 되면 동일값이 Row에 여러개가 될 수 있음
  - 동일값을 가진 행이 없도록 테이블을 쪼개는 것
- 3NF (제 3정규형)
  - 제 2정규화를 진행한 테이블에 대해 이행적 종속 제거 목적으로 테이블을 분해
  - 이행적 종속이라함은 A->B, B->C 성립 때 A->C가 성립되는 것
- BCNF (Boyce-codd Normal Form)
  - 제 3정규화의 강화 버전 

## 정규화 단점

- 릴레이션 분해로 인해 릴레이션 간의 JOIN 연산 많아짐
- 질의에 대한 응답 시간 이슈 발생
- 조인 발생으로 인한 성능 저하 시 반정규화 적용도 고려

## 데이터베이스 구조: Architecture

- 3층 스키마: DB의 논리적 및 물리적 독립성 확보
- 3층 스키마 구조
  - 외부 스키마: 사용자 관점, 뷰 권한 설정
  - 개념 스키마: 전체 데이터베이스 구조, DB 규칙, 모델링
  - 내부 스키마: 물리적 구조 저장장치, 레코드 및 인덱스

- DB의 종류
  - 계층형, 네트워크, 관계형 데이터베이스

- DB키의 종류
  - 기본키: 대표성이 있는 후보키
  - 후보키: 유일성과 최소성(Not NULL)
  - 슈퍼키: 유일성은 만족, 최소성을 만족하지 않음
  - 대체키: 기본키를 선정하고 남은 후보키
  - 외래키: 어느 릴레이션이 다른 릴레이션의 기본키로 사용되는 키

- 분산 데이터베이스
  - 네트워크를 통해서 원격으로 분리된 데이터베이스

- 분산DB 투명성
  - 분할, 위치, 중복, 장애, 병행, 지역사상 투명성

- 분산DB 구조
  - 전역 스키마, 분할 스키마, 할당 스키마, 지역 개념 스키마, 지역 물리 스키마

- 2PC(Phase Commit): 분산 DB에서 Prepare와 Commit 단계를 트랜잭션의 일관성 확보
- DB 연동방법(Web DB 사용)
  - ODBC 및 JDBC
  - Middleware: Tuxedo
  - CGI 방식
  - FAST CGI
  - ISAPI
  - WAS(EJB)

## DB Modeling (가시화 및 의사소통)

- 개념적 모델링
  - 요구사항에서 후보 엔티티를 도출하고 관계를 수집
  - 개념적 ERD 작성
    - 엔티티(개체): 업무에서 관리하는 집합
    - 약한개체: 논리적 및 물리적으로 종속되는 개체
    - 강한개체: 한 개체가 다른 개체를 종속시키는 개체
    - 식별관계: 식별과 비식별 관계
- 엔티티 종류
  - 독립, 종속, 슈퍼 및 서브, 연관 엔티티 등
  - 개체의 관계종류: 자기관계, 상호배타적, 병렬관계 등
  - 카디날리티(Cardinality): 하나의 엔티티가 가질 수 있는 페어링 수(최소, 최대)
- 논리적 모델링
  - 개념적 모델을 관계형 모델로 변환
    - 1대1 관계: 완전 및 선택적
    - 1대N 관계: 기본키 및 외래키
    - M대N 관계: 연관 엔티티 사용
    - 다중 값 속성: 새로운 릴레이션 도출
    - 복합 속성: 여러 개의 컬럼으로 분류
  - 이상현상 제거
    - 정규화를 하지 않아서 발생되는 문제로 삽입, 삭제, 갱신 이상현상이 있음
  - 정규화(Normalization)
    - 함수적 종속성을 기반으로 DB중복을 제거하여 이상현상을 해결하는 과정
    - 종류
      - 제 1정규화: 애트리뷰트 원자성, 완전 함수 종속성
      - 제 2정규화: 부분함수 종속성 제거
      - 제 3정규화: 이행함수 종속성 제거
      - BCNF: 기본키를 제외한 후보키가 존재하고 후보키가 기본키를 종속하는 경우
      - 제 4정규화: 다중 값 종속성 제거
      - 제 5정규화: 결합 종속성 제거
  - 암스트롱 공리: DB 정규화에 사용되는 방법으로 함수적 종속성의 성질을 유도하는 방법
    - 부분집합의 성질
    - 확대(확대의 공리)
    - 이행성(이행의 공리)
    - 합집합의 성질
    - 분해의 성질
    - 유사 이행적 성질
  - 연결함정(Connection Trap)
    - 무손실 분해를 지키지 않아서 관계성을 잃어 버린 현상
    - 부채꼴 함정(Fan Trap)
    - 균열 함정(Chasm Trap)
  - 무결성(Integrity)
    - 무효 갱신으로 DB를 보호하는 특성으로 개체, 참조, 영역, 업무 무결성이 있음
  - 무결성 제약방법
    - 선언적(Not NULL, Unique, Primary Key, Check, Default, Foreign Key 등), 절차적(Trigger, Stored Procedure, Application)
- 물리적 모델링
  - DBMS의 구조에 맞는 모델링
  - 하드웨어 환경을 고려한 구성
  - 데이터베이스 튜닝, 반정규화

## Database Tuning (최적화)

- DBMS 시스템 구조
  - 고객, SQL, 메모리, 파일, 데이터, 로그, 제어정보, 운영체제, 네트워크

- 튜닝 접근 방법
  - 서버 튜닝
  - App 튜닝

- SQL 실행 절차
  - 구문 분석, 실행, 인출

- 옵티마이저(Optimizer): SQL의 실행계획을 수립하는 DBMS 소프트웨어

- 옵티마이저 종류
  - Rule Base Optimizer: 정해진 규칙
  - Cost Base Optimizer: 통계 정보

- DB Join 방식
  - Nested Loop Join: X를 찾고 Y를 찾는 방식
  - Sort Merge Join: SORT_AREA를 사용해서 병렬적으로 정렬과 머지를 실행하고 한번의 Full Scan 수행

- DB 튜닝 절차
  - 설계 튜닝
  - SQL 튜닝
  - DB 논리적 구조 튜닝
  - DB 메모리 튜닝
  - 입출력 튜닝
  - 자원경합 튜닝

- DB 인덱스 종류
  - 인덱스 선정
    - 기본키와 외래키
    - 접근경로 분석
    - 분포도 조사 = 평균 Row수 / 총 Row*100, 10~15%정도 컬럼이 인덱스 후보
    - 인덱스 순서: 결합 인덱스
  - 인덱스 종류
    - 단일 인덱스(Ordered Index)
    - 결합 인덱스(Combined Index)
    - 해시 인덱스(Hash Index): HASH_AREA 사용
    - 비트맵 인덱스(Bitmap Index): 0 혹은 1로 데이터를 표현
    - 클러스터 인덱스(Cluster Index): 물리적으로 인덱스를 정렬함